<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<!-- on Tue Jun 15 06:02:33 GMT 2021 -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="Apache Hadoop Common 3.3.1"
  jdversion="1.0.9">

<!--  Command line arguments =  -doclet org.apache.hadoop.classification.tools.IncludePublicAnnotationsJDiffDoclet -docletpath /build/source/hadoop-common-project/hadoop-common/target/hadoop-annotations.jar:/build/source/hadoop-common-project/hadoop-common/target/jdiff.jar -verbose -classpath /build/source/hadoop-common-project/hadoop-common/target/classes:/maven/org/apache/hadoop/thirdparty/hadoop-shaded-protobuf_3_7/1.1.1/hadoop-shaded-protobuf_3_7-1.1.1.jar:/build/source/hadoop-common-project/hadoop-annotations/target/hadoop-annotations-3.3.1.jar:/usr/lib/jvm/java-8-openjdk-amd64/lib/tools.jar:/maven/org/apache/hadoop/thirdparty/hadoop-shaded-guava/1.1.1/hadoop-shaded-guava-1.1.1.jar:/maven/com/google/guava/guava/27.0-jre/guava-27.0-jre.jar:/maven/com/google/guava/failureaccess/1.0/failureaccess-1.0.jar:/maven/com/google/guava/listenablefuture/9999.0-empty-to-avoid-conflict-with-guava/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar:/maven/org/checkerframework/checker-qual/2.5.2/checker-qual-2.5.2.jar:/maven/com/google/j2objc/j2objc-annotations/1.1/j2objc-annotations-1.1.jar:/maven/org/codehaus/mojo/animal-sniffer-annotations/1.17/animal-sniffer-annotations-1.17.jar:/maven/commons-cli/commons-cli/1.2/commons-cli-1.2.jar:/maven/org/apache/commons/commons-math3/3.1.1/commons-math3-3.1.1.jar:/maven/org/apache/httpcomponents/httpclient/4.5.13/httpclient-4.5.13.jar:/maven/org/apache/httpcomponents/httpcore/4.4.13/httpcore-4.4.13.jar:/maven/commons-codec/commons-codec/1.11/commons-codec-1.11.jar:/maven/commons-io/commons-io/2.8.0/commons-io-2.8.0.jar:/maven/commons-net/commons-net/3.6/commons-net-3.6.jar:/maven/commons-collections/commons-collections/3.2.2/commons-collections-3.2.2.jar:/maven/javax/servlet/javax.servlet-api/3.1.0/javax.servlet-api-3.1.0.jar:/maven/org/eclipse/jetty/jetty-server/9.4.40.v20210413/jetty-server-9.4.40.v20210413.jar:/maven/org/eclipse/jetty/jetty-http/9.4.40.v20210413/jetty-http-9.4.40.v20210413.jar:/maven/org/eclipse/jetty/jetty-io/9.4.40.v20210413/jetty-io-9.4.40.v20210413.jar:/maven/org/eclipse/jetty/jetty-util/9.4.40.v20210413/jetty-util-9.4.40.v20210413.jar:/maven/org/eclipse/jetty/jetty-servlet/9.4.40.v20210413/jetty-servlet-9.4.40.v20210413.jar:/maven/org/eclipse/jetty/jetty-security/9.4.40.v20210413/jetty-security-9.4.40.v20210413.jar:/maven/org/eclipse/jetty/jetty-webapp/9.4.40.v20210413/jetty-webapp-9.4.40.v20210413.jar:/maven/org/eclipse/jetty/jetty-xml/9.4.40.v20210413/jetty-xml-9.4.40.v20210413.jar:/maven/com/sun/jersey/jersey-core/1.19/jersey-core-1.19.jar:/maven/javax/ws/rs/jsr311-api/1.1.1/jsr311-api-1.1.1.jar:/maven/com/sun/jersey/jersey-servlet/1.19/jersey-servlet-1.19.jar:/maven/com/sun/jersey/jersey-json/1.19/jersey-json-1.19.jar:/maven/org/codehaus/jettison/jettison/1.1/jettison-1.1.jar:/maven/com/sun/xml/bind/jaxb-impl/2.2.3-1/jaxb-impl-2.2.3-1.jar:/maven/javax/xml/bind/jaxb-api/2.2.11/jaxb-api-2.2.11.jar:/maven/org/codehaus/jackson/jackson-core-asl/1.9.13/jackson-core-asl-1.9.13.jar:/maven/org/codehaus/jackson/jackson-mapper-asl/1.9.13/jackson-mapper-asl-1.9.13.jar:/maven/org/codehaus/jackson/jackson-jaxrs/1.9.13/jackson-jaxrs-1.9.13.jar:/maven/org/codehaus/jackson/jackson-xc/1.9.13/jackson-xc-1.9.13.jar:/maven/com/sun/jersey/jersey-server/1.19/jersey-server-1.19.jar:/maven/commons-logging/commons-logging/1.1.3/commons-logging-1.1.3.jar:/maven/log4j/log4j/1.2.17/log4j-1.2.17.jar:/maven/commons-beanutils/commons-beanutils/1.9.4/commons-beanutils-1.9.4.jar:/maven/org/apache/commons/commons-configuration2/2.1.1/commons-configuration2-2.1.1.jar:/maven/org/apache/commons/commons-lang3/3.7/commons-lang3-3.7.jar:/maven/org/apache/commons/commons-text/1.4/commons-text-1.4.jar:/maven/org/slf4j/slf4j-api/1.7.30/slf4j-api-1.7.30.jar:/maven/org/slf4j/slf4j-log4j12/1.7.30/slf4j-log4j12-1.7.30.jar:/maven/org/apache/avro/avro/1.7.7/avro-1.7.7.jar:/maven/com/thoughtworks/paranamer/paranamer/2.3/paranamer-2.3.jar:/maven/com/google/re2j/re2j/1.1/re2j-1.1.jar:/maven/com/google/protobuf/protobuf-java/2.5.0/protobuf-java-2.5.0.jar:/maven/com/google/code/gson/gson/2.2.4/gson-2.2.4.jar:/build/source/hadoop-common-project/hadoop-auth/target/hadoop-auth-3.3.1.jar:/maven/com/nimbusds/nimbus-jose-jwt/9.8.1/nimbus-jose-jwt-9.8.1.jar:/maven/com/github/stephenc/jcip/jcip-annotations/1.0-1/jcip-annotations-1.0-1.jar:/maven/net/minidev/json-smart/2.4.2/json-smart-2.4.2.jar:/maven/net/minidev/accessors-smart/2.4.2/accessors-smart-2.4.2.jar:/maven/org/ow2/asm/asm/5.0.4/asm-5.0.4.jar:/maven/org/apache/curator/curator-framework/4.2.0/curator-framework-4.2.0.jar:/maven/org/apache/kerby/kerb-simplekdc/1.0.1/kerb-simplekdc-1.0.1.jar:/maven/org/apache/kerby/kerb-client/1.0.1/kerb-client-1.0.1.jar:/maven/org/apache/kerby/kerby-config/1.0.1/kerby-config-1.0.1.jar:/maven/org/apache/kerby/kerb-common/1.0.1/kerb-common-1.0.1.jar:/maven/org/apache/kerby/kerb-crypto/1.0.1/kerb-crypto-1.0.1.jar:/maven/org/apache/kerby/kerb-util/1.0.1/kerb-util-1.0.1.jar:/maven/org/apache/kerby/token-provider/1.0.1/token-provider-1.0.1.jar:/maven/org/apache/kerby/kerb-admin/1.0.1/kerb-admin-1.0.1.jar:/maven/org/apache/kerby/kerb-server/1.0.1/kerb-server-1.0.1.jar:/maven/org/apache/kerby/kerb-identity/1.0.1/kerb-identity-1.0.1.jar:/maven/org/apache/kerby/kerby-xdr/1.0.1/kerby-xdr-1.0.1.jar:/maven/com/jcraft/jsch/0.1.55/jsch-0.1.55.jar:/maven/org/apache/curator/curator-client/4.2.0/curator-client-4.2.0.jar:/maven/org/apache/curator/curator-recipes/4.2.0/curator-recipes-4.2.0.jar:/maven/com/google/code/findbugs/jsr305/3.0.2/jsr305-3.0.2.jar:/maven/org/apache/htrace/htrace-core4/4.1.0-incubating/htrace-core4-4.1.0-incubating.jar:/maven/org/apache/zookeeper/zookeeper/3.5.6/zookeeper-3.5.6.jar:/maven/org/apache/zookeeper/zookeeper-jute/3.5.6/zookeeper-jute-3.5.6.jar:/maven/org/apache/yetus/audience-annotations/0.5.0/audience-annotations-0.5.0.jar:/maven/org/apache/commons/commons-compress/1.19/commons-compress-1.19.jar:/maven/org/apache/kerby/kerb-core/1.0.1/kerb-core-1.0.1.jar:/maven/org/apache/kerby/kerby-pkix/1.0.1/kerby-pkix-1.0.1.jar:/maven/org/apache/kerby/kerby-asn1/1.0.1/kerby-asn1-1.0.1.jar:/maven/org/apache/kerby/kerby-util/1.0.1/kerby-util-1.0.1.jar:/maven/com/fasterxml/jackson/core/jackson-databind/2.10.5.1/jackson-databind-2.10.5.1.jar:/maven/com/fasterxml/jackson/core/jackson-annotations/2.10.5/jackson-annotations-2.10.5.jar:/maven/com/fasterxml/jackson/core/jackson-core/2.10.5/jackson-core-2.10.5.jar:/maven/org/codehaus/woodstox/stax2-api/4.2.1/stax2-api-4.2.1.jar:/maven/com/fasterxml/woodstox/woodstox-core/5.3.0/woodstox-core-5.3.0.jar:/maven/dnsjava/dnsjava/2.1.7/dnsjava-2.1.7.jar:/maven/org/wildfly/openssl/wildfly-openssl-java/1.0.7.Final/wildfly-openssl-java-1.0.7.Final.jar:/maven/org/xerial/snappy/snappy-java/1.1.8.2/snappy-java-1.1.8.2.jar:/maven/org/lz4/lz4-java/1.7.1/lz4-java-1.7.1.jar:/maven/xerces/xercesImpl/2.11.0/xercesImpl-2.11.0.jar:/maven/xml-apis/xml-apis/1.4.01/xml-apis-1.4.01.jar -sourcepath /build/source/hadoop-common-project/hadoop-common/src/main/java -doclet org.apache.hadoop.classification.tools.IncludePublicAnnotationsJDiffDoclet -docletpath /build/source/hadoop-common-project/hadoop-common/target/hadoop-annotations.jar:/build/source/hadoop-common-project/hadoop-common/target/jdiff.jar -apidir /build/source/hadoop-common-project/hadoop-common/target/site/jdiff/xml -apiname Apache Hadoop Common 3.3.1 -->
<package name="org.apache.hadoop">
  <!-- start class org.apache.hadoop.HadoopIllegalArgumentException -->
  <class name="HadoopIllegalArgumentException" extends="java.lang.IllegalArgumentException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="HadoopIllegalArgumentException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs exception with the specified detail message. 
 @param message detailed message.]]>
      </doc>
    </constructor>
    <doc>
    <![CDATA[Indicates that a method has been passed illegal or invalid argument. This
 exception is thrown instead of IllegalArgumentException to differentiate the
 exception thrown in Hadoop implementation from the one thrown in JDK.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.HadoopIllegalArgumentException -->
</package>
<package name="org.apache.hadoop.conf">
  <!-- start interface org.apache.hadoop.conf.Configurable -->
  <interface name="Configurable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="setConf"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Set the configuration to be used by this object.
 @param conf configuration to be used]]>
      </doc>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the configuration used by this object.
 @return Configuration]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Something that may be configured with a {@link Configuration}.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.conf.Configurable -->
  <!-- start class org.apache.hadoop.conf.Configuration -->
  <class name="Configuration" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.lang.Iterable"/>
    <implements name="org.apache.hadoop.io.Writable"/>
    <constructor name="Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A new configuration.]]>
      </doc>
    </constructor>
    <constructor name="Configuration" type="boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A new configuration where the behavior of reading from the default 
 resources can be turned off.
 
 If the parameter {@code loadDefaults} is false, the new instance
 will not load resources from the default files. 
 @param loadDefaults specifies whether to load from the default files]]>
      </doc>
    </constructor>
    <constructor name="Configuration" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[A new configuration with the same settings cloned from another.
 
 @param other the configuration from which to clone settings.]]>
      </doc>
    </constructor>
    <method name="addDeprecations"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="deltas" type="org.apache.hadoop.conf.Configuration.DeprecationDelta[]"/>
      <doc>
      <![CDATA[Adds a set of deprecated keys to the global deprecations.

 This method is lockless.  It works by means of creating a new
 DeprecationContext based on the old one, and then atomically swapping in
 the new context.  If someone else updated the context in between us reading
 the old context and swapping in the new one, we try again until we win the
 race.

 @param deltas   The deprecations to add.]]>
      </doc>
    </method>
    <method name="addDeprecation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use {@link #addDeprecation(String key, String newKey,
      String customMessage)} instead">
      <param name="key" type="java.lang.String"/>
      <param name="newKeys" type="java.lang.String[]"/>
      <param name="customMessage" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds the deprecated key to the global deprecation map.
 It does not override any existing entries in the deprecation map.
 This is to be used only by the developers in order to add deprecation of
 keys, and attempts to call this method after loading resources once,
 would lead to <tt>UnsupportedOperationException</tt>
 
 If a key is deprecated in favor of multiple keys, they are all treated as 
 aliases of each other, and setting any one of them resets all the others 
 to the new value.

 If you have multiple deprecation entries to add, it is more efficient to
 use #addDeprecations(DeprecationDelta[] deltas) instead.
 
 @param key to be deprecated
 @param newKeys list of keys that take up the values of deprecated key
 @param customMessage depcrication message
 @deprecated use {@link #addDeprecation(String key, String newKey,
      String customMessage)} instead]]>
      </doc>
    </method>
    <method name="addDeprecation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="newKey" type="java.lang.String"/>
      <param name="customMessage" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds the deprecated key to the global deprecation map.
 It does not override any existing entries in the deprecation map.
 This is to be used only by the developers in order to add deprecation of
 keys, and attempts to call this method after loading resources once,
 would lead to <tt>UnsupportedOperationException</tt>
 
 If you have multiple deprecation entries to add, it is more efficient to
 use #addDeprecations(DeprecationDelta[] deltas) instead.

 @param key to be deprecated
 @param newKey key that take up the values of deprecated key
 @param customMessage deprecation message]]>
      </doc>
    </method>
    <method name="addDeprecation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="use {@link #addDeprecation(String key, String newKey)} instead">
      <param name="key" type="java.lang.String"/>
      <param name="newKeys" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Adds the deprecated key to the global deprecation map when no custom
 message is provided.
 It does not override any existing entries in the deprecation map.
 This is to be used only by the developers in order to add deprecation of
 keys, and attempts to call this method after loading resources once,
 would lead to <tt>UnsupportedOperationException</tt>
 
 If a key is deprecated in favor of multiple keys, they are all treated as 
 aliases of each other, and setting any one of them resets all the others 
 to the new value.
 
 If you have multiple deprecation entries to add, it is more efficient to
 use #addDeprecations(DeprecationDelta[] deltas) instead.

 @param key Key that is to be deprecated
 @param newKeys list of keys that take up the values of deprecated key
 @deprecated use {@link #addDeprecation(String key, String newKey)} instead]]>
      </doc>
    </method>
    <method name="addDeprecation"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="newKey" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds the deprecated key to the global deprecation map when no custom
 message is provided.
 It does not override any existing entries in the deprecation map.
 This is to be used only by the developers in order to add deprecation of
 keys, and attempts to call this method after loading resources once,
 would lead to <tt>UnsupportedOperationException</tt>
 
 If you have multiple deprecation entries to add, it is more efficient to
 use #addDeprecations(DeprecationDelta[] deltas) instead.

 @param key Key that is to be deprecated
 @param newKey key that takes up the value of deprecated key]]>
      </doc>
    </method>
    <method name="isDeprecated" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[checks whether the given <code>key</code> is deprecated.
 
 @param key the parameter which is to be checked for deprecation
 @return <code>true</code> if the key is deprecated and 
         <code>false</code> otherwise.]]>
      </doc>
    </method>
    <method name="setDeprecatedProperties"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Sets all deprecated properties that are not currently set but have a
 corresponding new property that is set. Useful for iterating the
 properties when all deprecated properties for currently set properties
 need to be present.]]>
      </doc>
    </method>
    <method name="reloadExistingConfigurations"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reload existing configuration instances.]]>
      </doc>
    </method>
    <method name="addDefaultResource"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Add a default resource. Resources are loaded in the order of the resources 
 added.
 @param name file name. File should be present in the classpath.]]>
      </doc>
    </method>
    <method name="setRestrictSystemPropertiesDefault"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="boolean"/>
    </method>
    <method name="setRestrictSystemProperties"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="boolean"/>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Add a configuration resource. 
 
 The properties of this resource will override properties of previously 
 added resources, unless they were marked <a href="#Final">final</a>. 
 
 @param name resource to be added, the classpath is examined for a file 
             with that name.]]>
      </doc>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="restrictedParser" type="boolean"/>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <doc>
      <![CDATA[Add a configuration resource. 
 
 The properties of this resource will override properties of previously 
 added resources, unless they were marked <a href="#Final">final</a>. 
 
 @param url url of the resource to be added, the local filesystem is 
            examined directly to find the resource, without referring to 
            the classpath.]]>
      </doc>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="url" type="java.net.URL"/>
      <param name="restrictedParser" type="boolean"/>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Add a configuration resource. 
 
 The properties of this resource will override properties of previously 
 added resources, unless they were marked <a href="#Final">final</a>. 
 
 @param file file-path of resource to be added, the local filesystem is
             examined directly to find the resource, without referring to 
             the classpath.]]>
      </doc>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <param name="restrictedParser" type="boolean"/>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <doc>
      <![CDATA[Add a configuration resource. 
 
 The properties of this resource will override properties of previously 
 added resources, unless they were marked <a href="#Final">final</a>. 
 
 WARNING: The contents of the InputStream will be cached, by this method. 
 So use this sparingly because it does increase the memory consumption.
 
 @param in InputStream to deserialize the object from. In will be read from
 when a get or set is called next.  After it is read the stream will be
 closed.]]>
      </doc>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="restrictedParser" type="boolean"/>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Add a configuration resource. 
 
 The properties of this resource will override properties of previously 
 added resources, unless they were marked <a href="#Final">final</a>. 
 
 @param in InputStream to deserialize the object from.
 @param name the name of the resource because InputStream.toString is not
 very descriptive some times.]]>
      </doc>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <param name="name" type="java.lang.String"/>
      <param name="restrictedParser" type="boolean"/>
    </method>
    <method name="addResource"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Add a configuration resource.

 The properties of this resource will override properties of previously
 added resources, unless they were marked <a href="#Final">final</a>.

 @param conf Configuration object from which to load properties]]>
      </doc>
    </method>
    <method name="reloadConfiguration"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reload configuration from previously added resources.

 This method will clear all the configuration read from the added 
 resources, and final parameters. This will make the resources to 
 be read again before accessing the values. Values that are added
 via set methods will overlay values read from the resources.]]>
      </doc>
    </method>
    <method name="get" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property, <code>null</code> if
 no such property exists. If the key is deprecated, it returns the value of
 the first key which replaces the deprecated key and is not null.
 
 Values are processed for <a href="#VariableExpansion">variable expansion</a> 
 before being returned.

 As a side effect get loads the properties from the sources if called for
 the first time as a lazy init.
 
 @param name the property name, will be trimmed before get value.
 @return the value of the <code>name</code> or its replacing property, 
         or null if no such property exists.]]>
      </doc>
    </method>
    <method name="setAllowNullValueProperties"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="boolean"/>
      <doc>
      <![CDATA[Set Configuration to allow keys without values during setup.  Intended
 for use during testing.

 @param val If true, will allow Configuration to store keys without values]]>
      </doc>
    </method>
    <method name="setRestrictSystemProps"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="val" type="boolean"/>
    </method>
    <method name="onlyKeyExists" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Return existence of the <code>name</code> property, but only for
 names which have no valid value, usually non-existent or commented
 out in XML.

 @param name the property name
 @return true if the property <code>name</code> exists without value]]>
      </doc>
    </method>
    <method name="getTrimmed" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a trimmed <code>String</code>, 
 <code>null</code> if no such property exists. 
 If the key is deprecated, it returns the value of
 the first key which replaces the deprecated key and is not null
 
 Values are processed for <a href="#VariableExpansion">variable expansion</a> 
 before being returned. 
 
 @param name the property name.
 @return the value of the <code>name</code> or its replacing property, 
         or null if no such property exists.]]>
      </doc>
    </method>
    <method name="getTrimmed" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a trimmed <code>String</code>, 
 <code>defaultValue</code> if no such property exists. 
 See @{Configuration#getTrimmed} for more details.
 
 @param name          the property name.
 @param defaultValue  the property default value.
 @return              the value of the <code>name</code> or defaultValue
                      if it is not set.]]>
      </doc>
    </method>
    <method name="getRaw" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property, without doing
 <a href="#VariableExpansion">variable expansion</a>.If the key is 
 deprecated, it returns the value of the first key which replaces 
 the deprecated key and is not null.
 
 @param name the property name.
 @return the value of the <code>name</code> property or 
         its replacing property and null if no such property exists.]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Set the <code>value</code> of the <code>name</code> property. If 
 <code>name</code> is deprecated or there is a deprecated name associated to it,
 it sets the value to both names. Name will be trimmed before put into
 configuration.
 
 @param name property name.
 @param value property value.]]>
      </doc>
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <param name="source" type="java.lang.String"/>
      <doc>
      <![CDATA[Set the <code>value</code> of the <code>name</code> property. If 
 <code>name</code> is deprecated, it also sets the <code>value</code> to
 the keys that replace the deprecated key. Name will be trimmed before put
 into configuration.

 @param name property name.
 @param value property value.
 @param source the place that this configuration value came from 
 (For debugging).
 @throws IllegalArgumentException when the value or name is null.]]>
      </doc>
    </method>
    <method name="unset"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Unset a previously set property.
 @param name the property name]]>
      </doc>
    </method>
    <method name="setIfUnset"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets a property if it is currently unset.
 @param name the property name
 @param value the new value]]>
      </doc>
    </method>
    <method name="get" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code>. If the key is deprecated,
 it returns the value of the first key which replaces the deprecated key
 and is not null.
 If no such property exists,
 then <code>defaultValue</code> is returned.
 
 @param name property name, will be trimmed before get value.
 @param defaultValue default value.
 @return property value, or <code>defaultValue</code> if the property 
         doesn't exist.]]>
      </doc>
    </method>
    <method name="getInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="int"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as an <code>int</code>.
   
 If no such property exists, the provided default value is returned,
 or if the specified value is not a valid <code>int</code>,
 then an error is thrown.
 
 @param name property name.
 @param defaultValue default value.
 @throws NumberFormatException when the value is invalid
 @return property value as an <code>int</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="getInts" return="int[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a set of comma-delimited
 <code>int</code> values.
 
 If no such property exists, an empty array is returned.
 
 @param name property name
 @return property value interpreted as an array of comma-delimited
         <code>int</code> values]]>
      </doc>
    </method>
    <method name="setInt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="int"/>
      <doc>
      <![CDATA[Set the value of the <code>name</code> property to an <code>int</code>.
 
 @param name property name.
 @param value <code>int</code> value of the property.]]>
      </doc>
    </method>
    <method name="getLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="long"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>long</code>.  
 If no such property exists, the provided default value is returned,
 or if the specified value is not a valid <code>long</code>,
 then an error is thrown.
 
 @param name property name.
 @param defaultValue default value.
 @throws NumberFormatException when the value is invalid
 @return property value as a <code>long</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="getLongBytes" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="long"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>long</code> or
 human readable format. If no such property exists, the provided default
 value is returned, or if the specified value is not a valid
 <code>long</code> or human readable format, then an error is thrown. You
 can use the following suffix (case insensitive): k(kilo), m(mega), g(giga),
 t(tera), p(peta), e(exa)

 @param name property name.
 @param defaultValue default value.
 @throws NumberFormatException when the value is invalid
 @return property value as a <code>long</code>,
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="setLong"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="long"/>
      <doc>
      <![CDATA[Set the value of the <code>name</code> property to a <code>long</code>.
 
 @param name property name.
 @param value <code>long</code> value of the property.]]>
      </doc>
    </method>
    <method name="getFloat" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="float"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>float</code>.  
 If no such property exists, the provided default value is returned,
 or if the specified value is not a valid <code>float</code>,
 then an error is thrown.

 @param name property name.
 @param defaultValue default value.
 @throws NumberFormatException when the value is invalid
 @return property value as a <code>float</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="setFloat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="float"/>
      <doc>
      <![CDATA[Set the value of the <code>name</code> property to a <code>float</code>.
 
 @param name property name.
 @param value property value.]]>
      </doc>
    </method>
    <method name="getDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="double"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>double</code>.  
 If no such property exists, the provided default value is returned,
 or if the specified value is not a valid <code>double</code>,
 then an error is thrown.

 @param name property name.
 @param defaultValue default value.
 @throws NumberFormatException when the value is invalid
 @return property value as a <code>double</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="setDouble"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="double"/>
      <doc>
      <![CDATA[Set the value of the <code>name</code> property to a <code>double</code>.
 
 @param name property name.
 @param value property value.]]>
      </doc>
    </method>
    <method name="getBoolean" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="boolean"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>boolean</code>.  
 If no such property is specified, or if the specified value is not a valid
 <code>boolean</code>, then <code>defaultValue</code> is returned.
 
 @param name property name.
 @param defaultValue default value.
 @return property value as a <code>boolean</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="setBoolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Set the value of the <code>name</code> property to a <code>boolean</code>.
 
 @param name property name.
 @param value <code>boolean</code> value of the property.]]>
      </doc>
    </method>
    <method name="setBooleanIfUnset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="boolean"/>
      <doc>
      <![CDATA[Set the given property, if it is currently unset.
 @param name property name
 @param value new value]]>
      </doc>
    </method>
    <method name="setEnum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="T"/>
      <doc>
      <![CDATA[Set the value of the <code>name</code> property to the given type. This
 is equivalent to <code>set(&lt;name&gt;, value.toString())</code>.
 @param name property name
 @param value new value
 @param <T> enumeration type]]>
      </doc>
    </method>
    <method name="getEnum" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="T"/>
      <doc>
      <![CDATA[Return value matching this enumerated type.
 Note that the returned value is trimmed by this method.
 @param name Property name
 @param defaultValue Value returned if no mapping exists
 @param <T> enumeration type
 @throws IllegalArgumentException If mapping is illegal for the type
 provided
 @return enumeration type]]>
      </doc>
    </method>
    <method name="setTimeDuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Set the value of <code>name</code> to the given time duration. This
 is equivalent to <code>set(&lt;name&gt;, value + &lt;time suffix&gt;)</code>.
 @param name Property name
 @param value Time duration
 @param unit Unit of time]]>
      </doc>
    </method>
    <method name="getTimeDuration" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="long"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Return time duration in the given time unit. Valid units are encoded in
 properties as suffixes: nanoseconds (ns), microseconds (us), milliseconds
 (ms), seconds (s), minutes (m), hours (h), and days (d).

 @param name Property name
 @param defaultValue Value returned if no mapping exists.
 @param unit Unit to convert the stored property, if it exists.
 @throws NumberFormatException If the property stripped of its unit is not
         a number
 @return time duration in given time unit]]>
      </doc>
    </method>
    <method name="getTimeDuration" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.String"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="getTimeDuration" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="long"/>
      <param name="defaultUnit" type="java.util.concurrent.TimeUnit"/>
      <param name="returnUnit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Return time duration in the given time unit. Valid units are encoded in
 properties as suffixes: nanoseconds (ns), microseconds (us), milliseconds
 (ms), seconds (s), minutes (m), hours (h), and days (d). If no unit is
 provided, the default unit is applied.

 @param name Property name
 @param defaultValue Value returned if no mapping exists.
 @param defaultUnit Default time unit if no valid suffix is provided.
 @param returnUnit The unit used for the returned value.
 @throws NumberFormatException If the property stripped of its unit is not
         a number
 @return time duration in given time unit]]>
      </doc>
    </method>
    <method name="getTimeDuration" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.String"/>
      <param name="defaultUnit" type="java.util.concurrent.TimeUnit"/>
      <param name="returnUnit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="getTimeDurationHelper" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="vStr" type="java.lang.String"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
      <doc>
      <![CDATA[Return time duration in the given time unit. Valid units are encoded in
 properties as suffixes: nanoseconds (ns), microseconds (us), milliseconds
 (ms), seconds (s), minutes (m), hours (h), and days (d).

 @param name Property name
 @param vStr The string value with time unit suffix to be converted.
 @param unit Unit to convert the stored property, if it exists.]]>
      </doc>
    </method>
    <method name="getTimeDurations" return="long[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="unit" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="getStorageSize" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.String"/>
      <param name="targetUnit" type="org.apache.hadoop.conf.StorageUnit"/>
      <doc>
      <![CDATA[Gets the Storage Size from the config, or returns the defaultValue. The
 unit of return value is specified in target unit.

 @param name - Key Name
 @param defaultValue - Default Value -- e.g. 100MB
 @param targetUnit - The units that we want result to be in.
 @return double -- formatted in target Units]]>
      </doc>
    </method>
    <method name="getStorageSize" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="double"/>
      <param name="targetUnit" type="org.apache.hadoop.conf.StorageUnit"/>
      <doc>
      <![CDATA[Gets storage size from a config file.

 @param name - Key to read.
 @param defaultValue - The default value to return in case the key is
 not present.
 @param targetUnit - The Storage unit that should be used
 for the return value.
 @return - double value in the Storage Unit specified.]]>
      </doc>
    </method>
    <method name="setStorageSize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="double"/>
      <param name="unit" type="org.apache.hadoop.conf.StorageUnit"/>
      <doc>
      <![CDATA[Sets Storage Size for the specified key.

 @param name - Key to set.
 @param value - The numeric value to set.
 @param unit - Storage Unit to be used.]]>
      </doc>
    </method>
    <method name="getPattern" return="java.util.regex.Pattern"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.util.regex.Pattern"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>Pattern</code>.
 If no such property is specified, or if the specified value is not a valid
 <code>Pattern</code>, then <code>DefaultValue</code> is returned.
 Note that the returned value is NOT trimmed by this method.

 @param name property name
 @param defaultValue default value
 @return property value as a compiled Pattern, or defaultValue]]>
      </doc>
    </method>
    <method name="setPattern"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="pattern" type="java.util.regex.Pattern"/>
      <doc>
      <![CDATA[Set the given property to <code>Pattern</code>.
 If the pattern is passed as null, sets the empty pattern which results in
 further calls to getPattern(...) returning the default value.

 @param name property name
 @param pattern new value]]>
      </doc>
    </method>
    <method name="getPropertySources" return="java.lang.String[]"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Gets information about why a property was set.  Typically this is the 
 path to the resource objects (file, URL, etc.) the property came from, but
 it can also indicate that it was set programmatically, or because of the
 command line.

 @param name - The property name to get the source of.
 @return null - If the property or its source wasn't found. Otherwise, 
 returns a list of the sources of the resource.  The older sources are
 the first ones in the list.  So for example if a configuration is set from
 the command line, and then written out to a file that is read back in the
 first entry would indicate that it was set from the command line, while
 the second one would indicate the file that the new configuration was read
 in from.]]>
      </doc>
    </method>
    <method name="getRange" return="org.apache.hadoop.conf.Configuration.IntegerRanges"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.String"/>
      <doc>
      <![CDATA[Parse the given attribute as a set of integer ranges
 @param name the attribute name
 @param defaultValue the default value if it is not set
 @return a new set of ranges from the configured value]]>
      </doc>
    </method>
    <method name="getStringCollection" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the comma delimited values of the <code>name</code> property as 
 a collection of <code>String</code>s.  
 If no such property is specified then empty collection is returned.
 <p>
 This is an optimized version of {@link #getStrings(String)}
 
 @param name property name.
 @return property value as a collection of <code>String</code>s.]]>
      </doc>
    </method>
    <method name="getStrings" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the comma delimited values of the <code>name</code> property as 
 an array of <code>String</code>s.  
 If no such property is specified then <code>null</code> is returned.
 
 @param name property name.
 @return property value as an array of <code>String</code>s, 
         or <code>null</code>.]]>
      </doc>
    </method>
    <method name="getStrings" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Get the comma delimited values of the <code>name</code> property as 
 an array of <code>String</code>s.  
 If no such property is specified then default value is returned.
 
 @param name property name.
 @param defaultValue The default value
 @return property value as an array of <code>String</code>s, 
         or default value.]]>
      </doc>
    </method>
    <method name="getTrimmedStringCollection" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the comma delimited values of the <code>name</code> property as 
 a collection of <code>String</code>s, trimmed of the leading and trailing whitespace.  
 If no such property is specified then empty <code>Collection</code> is returned.

 @param name property name.
 @return property value as a collection of <code>String</code>s, or empty <code>Collection</code>]]>
      </doc>
    </method>
    <method name="getTrimmedStrings" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the comma delimited values of the <code>name</code> property as 
 an array of <code>String</code>s, trimmed of the leading and trailing whitespace.
 If no such property is specified then an empty array is returned.
 
 @param name property name.
 @return property value as an array of trimmed <code>String</code>s, 
         or empty array.]]>
      </doc>
    </method>
    <method name="getTrimmedStrings" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Get the comma delimited values of the <code>name</code> property as 
 an array of <code>String</code>s, trimmed of the leading and trailing whitespace.
 If no such property is specified then default value is returned.
 
 @param name property name.
 @param defaultValue The default value
 @return property value as an array of trimmed <code>String</code>s, 
         or default value.]]>
      </doc>
    </method>
    <method name="setStrings"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="values" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Set the array of string values for the <code>name</code> property as 
 as comma delimited values.  
 
 @param name property name.
 @param values The values]]>
      </doc>
    </method>
    <method name="getPassword" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the value for a known password configuration element.
 In order to enable the elimination of clear text passwords in config,
 this method attempts to resolve the property name as an alias through
 the CredentialProvider API and conditionally fallsback to config.
 @param name property name
 @return password
 @throws IOException when error in fetching password]]>
      </doc>
    </method>
    <method name="getPasswordFromCredentialProviders" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Try and resolve the provided element name as a credential provider
 alias.
 @param name alias of the provisioned credential
 @return password or null if not found
 @throws IOException when error in fetching password]]>
      </doc>
    </method>
    <method name="getPasswordFromConfig" return="char[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Fallback to clear text passwords in configuration.
 @param name
 @return clear text password or null]]>
      </doc>
    </method>
    <method name="getSocketAddr" return="java.net.InetSocketAddress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hostProperty" type="java.lang.String"/>
      <param name="addressProperty" type="java.lang.String"/>
      <param name="defaultAddressValue" type="java.lang.String"/>
      <param name="defaultPort" type="int"/>
      <doc>
      <![CDATA[Get the socket address for <code>hostProperty</code> as a
 <code>InetSocketAddress</code>. If <code>hostProperty</code> is
 <code>null</code>, <code>addressProperty</code> will be used. This
 is useful for cases where we want to differentiate between host
 bind address and address clients should use to establish connection.

 @param hostProperty bind host property name.
 @param addressProperty address property name.
 @param defaultAddressValue the default value
 @param defaultPort the default port
 @return InetSocketAddress]]>
      </doc>
    </method>
    <method name="getSocketAddr" return="java.net.InetSocketAddress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultAddress" type="java.lang.String"/>
      <param name="defaultPort" type="int"/>
      <doc>
      <![CDATA[Get the socket address for <code>name</code> property as a
 <code>InetSocketAddress</code>.
 @param name property name.
 @param defaultAddress the default value
 @param defaultPort the default port
 @return InetSocketAddress]]>
      </doc>
    </method>
    <method name="setSocketAddr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="addr" type="java.net.InetSocketAddress"/>
      <doc>
      <![CDATA[Set the socket address for the <code>name</code> property as
 a <code>host:port</code>.]]>
      </doc>
    </method>
    <method name="updateConnectAddr" return="java.net.InetSocketAddress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hostProperty" type="java.lang.String"/>
      <param name="addressProperty" type="java.lang.String"/>
      <param name="defaultAddressValue" type="java.lang.String"/>
      <param name="addr" type="java.net.InetSocketAddress"/>
      <doc>
      <![CDATA[Set the socket address a client can use to connect for the
 <code>name</code> property as a <code>host:port</code>.  The wildcard
 address is replaced with the local host's address. If the host and address
 properties are configured the host component of the address will be combined
 with the port component of the addr to generate the address.  This is to allow
 optional control over which host name is used in multi-home bind-host
 cases where a host can have multiple names
 @param hostProperty the bind-host configuration name
 @param addressProperty the service address configuration name
 @param defaultAddressValue the service default address configuration value
 @param addr InetSocketAddress of the service listener
 @return InetSocketAddress for clients to connect]]>
      </doc>
    </method>
    <method name="updateConnectAddr" return="java.net.InetSocketAddress"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="addr" type="java.net.InetSocketAddress"/>
      <doc>
      <![CDATA[Set the socket address a client can use to connect for the
 <code>name</code> property as a <code>host:port</code>.  The wildcard
 address is replaced with the local host's address.
 @param name property name.
 @param addr InetSocketAddress of a listener to store in the given property
 @return InetSocketAddress for clients to connect]]>
      </doc>
    </method>
    <method name="getClassByName" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="ClassNotFoundException" type="java.lang.ClassNotFoundException"/>
      <doc>
      <![CDATA[Load a class by name.
 
 @param name the class name.
 @return the class object.
 @throws ClassNotFoundException if the class is not found.]]>
      </doc>
    </method>
    <method name="getClassByNameOrNull" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Load a class by name, returning null rather than throwing an exception
 if it couldn't be loaded. This is to avoid the overhead of creating
 an exception.
 
 @param name the class name
 @return the class object, or null if it could not be found.]]>
      </doc>
    </method>
    <method name="getClasses" return="java.lang.Class[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.Class[]"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property
 as an array of <code>Class</code>.
 The value of the property specifies a list of comma separated class names.  
 If no such property is specified, then <code>defaultValue</code> is 
 returned.
 
 @param name the property name.
 @param defaultValue default value.
 @return property value as a <code>Class[]</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="getClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.Class"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>Class</code>.  
 If no such property is specified, then <code>defaultValue</code> is 
 returned.
 
 @param name the conf key name.
 @param defaultValue default value.
 @return property value as a <code>Class</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="getClass" return="java.lang.Class"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.Class"/>
      <param name="xface" type="java.lang.Class"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>Class</code>
 implementing the interface specified by <code>xface</code>.
   
 If no such property is specified, then <code>defaultValue</code> is 
 returned.
 
 An exception is thrown if the returned class does not implement the named
 interface. 
 
 @param name the conf key name.
 @param defaultValue default value.
 @param xface the interface implemented by the named class.
 @return property value as a <code>Class</code>, 
         or <code>defaultValue</code>.]]>
      </doc>
    </method>
    <method name="getInstances" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="xface" type="java.lang.Class"/>
      <doc>
      <![CDATA[Get the value of the <code>name</code> property as a <code>List</code>
 of objects implementing the interface specified by <code>xface</code>.
 
 An exception is thrown if any of the classes does not exist, or if it does
 not implement the named interface.
 
 @param name the property name.
 @param xface the interface implemented by the classes named by
        <code>name</code>.
 @return a <code>List</code> of objects implementing <code>xface</code>.]]>
      </doc>
    </method>
    <method name="setClass"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="theClass" type="java.lang.Class"/>
      <param name="xface" type="java.lang.Class"/>
      <doc>
      <![CDATA[Set the value of the <code>name</code> property to the name of a 
 <code>theClass</code> implementing the given interface <code>xface</code>.
 
 An exception is thrown if <code>theClass</code> does not implement the 
 interface <code>xface</code>. 
 
 @param name property name.
 @param theClass property value.
 @param xface the interface implemented by the named class.]]>
      </doc>
    </method>
    <method name="getLocalPath" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dirsProp" type="java.lang.String"/>
      <param name="path" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get a local file under a directory named by <i>dirsProp</i> with
 the given <i>path</i>.  If <i>dirsProp</i> contains multiple directories,
 then one is chosen based on <i>path</i>'s hash code.  If the selected
 directory does not exist, an attempt is made to create it.
 
 @param dirsProp directory in which to locate the file.
 @param path file-path.
 @return local file under the directory with the given path.]]>
      </doc>
    </method>
    <method name="getFile" return="java.io.File"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dirsProp" type="java.lang.String"/>
      <param name="path" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get a local file name under a directory named in <i>dirsProp</i> with
 the given <i>path</i>.  If <i>dirsProp</i> contains multiple directories,
 then one is chosen based on <i>path</i>'s hash code.  If the selected
 directory does not exist, an attempt is made to create it.
 
 @param dirsProp directory in which to locate the file.
 @param path file-path.
 @return local file under the directory with the given path.]]>
      </doc>
    </method>
    <method name="getResource" return="java.net.URL"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get the {@link URL} for the named resource.
 
 @param name resource name.
 @return the url for the named resource.]]>
      </doc>
    </method>
    <method name="getConfResourceAsInputStream" return="java.io.InputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get an input stream attached to the configuration resource with the
 given <code>name</code>.
 
 @param name configuration resource name.
 @return an input stream attached to the resource.]]>
      </doc>
    </method>
    <method name="getConfResourceAsReader" return="java.io.Reader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get a {@link Reader} attached to the configuration resource with the
 given <code>name</code>.
 
 @param name configuration resource name.
 @return a reader attached to the resource.]]>
      </doc>
    </method>
    <method name="getFinalParameters" return="java.util.Set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the set of parameters marked final.

 @return final parameter set.]]>
      </doc>
    </method>
    <method name="getProps" return="java.util.Properties"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="size" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the number of keys in the configuration.

 @return number of keys in the configuration.]]>
      </doc>
    </method>
    <method name="clear"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Clears all keys from the configuration.]]>
      </doc>
    </method>
    <method name="iterator" return="java.util.Iterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get an {@link Iterator} to go through the list of <code>String</code> 
 key-value pairs in the configuration.
 
 @return an iterator over the entries.]]>
      </doc>
    </method>
    <method name="getPropsWithPrefix" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="confPrefix" type="java.lang.String"/>
      <doc>
      <![CDATA[Constructs a mapping of configuration and includes all properties that
 start with the specified configuration prefix.  Property names in the
 mapping are trimmed to remove the configuration prefix.

 @param confPrefix configuration prefix
 @return mapping of configuration properties with prefix stripped]]>
      </doc>
    </method>
    <method name="addTags"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="prop" type="java.util.Properties"/>
      <doc>
      <![CDATA[Add tags defined in HADOOP_TAGS_SYSTEM, HADOOP_TAGS_CUSTOM.
 @param prop]]>
      </doc>
    </method>
    <method name="writeXml"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.OutputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Write out the non-default properties in this configuration to the given
 {@link OutputStream} using UTF-8 encoding.
 
 @param out the output stream to write to.]]>
      </doc>
    </method>
    <method name="writeXml"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.Writer"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="writeXml"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="propertyName" type="java.lang.String"/>
      <param name="out" type="java.io.Writer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="IllegalArgumentException" type="java.lang.IllegalArgumentException"/>
      <doc>
      <![CDATA[Write out the non-default properties in this configuration to the
 given {@link Writer}.
 <ul>
 <li>
 When property name is not empty and the property exists in the
 configuration, this method writes the property and its attributes
 to the {@link Writer}.
 </li>

 <li>
 When property name is null or empty, this method writes all the
 configuration properties and their attributes to the {@link Writer}.
 </li>

 <li>
 When property name is not empty but the property doesn't exist in
 the configuration, this method throws an {@link IllegalArgumentException}.
 </li>
 </ul>
 @param out the writer to write to.]]>
      </doc>
    </method>
    <method name="dumpConfiguration"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="org.apache.hadoop.conf.Configuration"/>
      <param name="propertyName" type="java.lang.String"/>
      <param name="out" type="java.io.Writer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes properties and their attributes (final and resource)
  to the given {@link Writer}.
  <ul>
  <li>
  When propertyName is not empty, and the property exists
  in the configuration, the format of the output would be,
  <pre>
  {
    "property": {
      "key" : "key1",
      "value" : "value1",
      "isFinal" : "key1.isFinal",
      "resource" : "key1.resource"
    }
  }
  </pre>
  </li>

  <li>
  When propertyName is null or empty, it behaves same as
  {@link #dumpConfiguration(Configuration, Writer)}, the
  output would be,
  <pre>
  { "properties" :
      [ { key : "key1",
          value : "value1",
          isFinal : "key1.isFinal",
          resource : "key1.resource" },
        { key : "key2",
          value : "value2",
          isFinal : "ke2.isFinal",
          resource : "key2.resource" }
       ]
   }
  </pre>
  </li>

  <li>
  When propertyName is not empty, and the property is not
  found in the configuration, this method will throw an
  {@link IllegalArgumentException}.
  </li>
  </ul>
  <p>
 @param config the configuration
 @param propertyName property name
 @param out the Writer to write to
 @throws IOException
 @throws IllegalArgumentException when property name is not
   empty and the property is not found in configuration]]>
      </doc>
    </method>
    <method name="dumpConfiguration"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="org.apache.hadoop.conf.Configuration"/>
      <param name="out" type="java.io.Writer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Writes out all properties and their attributes (final and resource) to
  the given {@link Writer}, the format of the output would be,

  <pre>
  { "properties" :
      [ { key : "key1",
          value : "value1",
          isFinal : "key1.isFinal",
          resource : "key1.resource" },
        { key : "key2",
          value : "value2",
          isFinal : "ke2.isFinal",
          resource : "key2.resource" }
       ]
   }
  </pre>

  It does not output the properties of the configuration object which
  is loaded from an input stream.
  <p>

 @param config the configuration
 @param out the Writer to write to
 @throws IOException]]>
      </doc>
    </method>
    <method name="getClassLoader" return="java.lang.ClassLoader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the {@link ClassLoader} for this job.

 @return the correct class loader.]]>
      </doc>
    </method>
    <method name="setClassLoader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="classLoader" type="java.lang.ClassLoader"/>
      <doc>
      <![CDATA[Set the class loader that will be used to load the various objects.
 
 @param classLoader the new class loader.]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setQuietMode"
      abstract="false" native="false" synchronized="true"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="quietmode" type="boolean"/>
      <doc>
      <![CDATA[Set the quietness-mode. 
 
 In the quiet-mode, error and informational messages might not be logged.
 
 @param quietmode <code>true</code> to set quiet-mode on, <code>false</code>
              to turn it off.]]>
      </doc>
    </method>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[For debugging.  List non-default properties to the terminal and exit.]]>
      </doc>
    </method>
    <method name="readFields"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.DataInput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="out" type="java.io.DataOutput"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getValByRegex" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="regex" type="java.lang.String"/>
      <doc>
      <![CDATA[get keys matching the the regex 
 @param regex
 @return {@literal Map<String,String>} with matching keys]]>
      </doc>
    </method>
    <method name="dumpDeprecatedKeys"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hasWarnedDeprecation" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns whether or not a deprecated name has been warned. If the name is not
 deprecated then always return false]]>
      </doc>
    </method>
    <method name="getAllPropertiesByTag" return="java.util.Properties"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tag" type="java.lang.String"/>
      <doc>
      <![CDATA[Get all properties belonging to tag.
 @param tag tag
 @return Properties with matching tag]]>
      </doc>
    </method>
    <method name="getAllPropertiesByTags" return="java.util.Properties"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tagList" type="java.util.List"/>
      <doc>
      <![CDATA[Get all properties belonging to list of input tags. Calls
 getAllPropertiesByTag internally.
 @param tagList list of input tags
 @return Properties with matching tags]]>
      </doc>
    </method>
    <method name="isPropertyTag" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="tagStr" type="java.lang.String"/>
      <doc>
      <![CDATA[Get Property tag Enum corresponding to given source.

 @param tagStr String representation of Enum
 @return true if tagStr is a valid tag]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Provides access to configuration parameters.

 <h3 id="Resources">Resources</h3>

 <p>Configurations are specified by resources. A resource contains a set of
 name/value pairs as XML data. Each resource is named by either a 
 <code>String</code> or by a {@link Path}. If named by a <code>String</code>, 
 then the classpath is examined for a file with that name.  If named by a 
 <code>Path</code>, then the local filesystem is examined directly, without 
 referring to the classpath.

 <p>Unless explicitly turned off, Hadoop by default specifies two 
 resources, loaded in-order from the classpath: <ol>
 <li><tt>
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a></tt>: Read-only defaults for hadoop.</li>
 <li><tt>core-site.xml</tt>: Site-specific configuration for a given hadoop
 installation.</li>
 </ol>
 Applications may add additional resources, which are loaded
 subsequent to these resources in the order they are added.
 
 <h4 id="FinalParams">Final Parameters</h4>

 <p>Configuration parameters may be declared <i>final</i>. 
 Once a resource declares a value final, no subsequently-loaded 
 resource can alter that value.  
 For example, one might define a final parameter with:
 <pre><code>
  &lt;property&gt;
    &lt;name&gt;dfs.hosts.include&lt;/name&gt;
    &lt;value&gt;/etc/hadoop/conf/hosts.include&lt;/value&gt;
    <b>&lt;final&gt;true&lt;/final&gt;</b>
  &lt;/property&gt;</code></pre>

 Administrators typically define parameters as final in 
 <tt>core-site.xml</tt> for values that user applications may not alter.

 <h4 id="VariableExpansion">Variable Expansion</h4>

 <p>Value strings are first processed for <i>variable expansion</i>. The
 available properties are:<ol>
 <li>Other properties defined in this Configuration; and, if a name is
 undefined here,</li>
 <li>Environment variables in {@link System#getenv()} if a name starts with
 "env.", or</li>
 <li>Properties in {@link System#getProperties()}.</li>
 </ol>

 <p>For example, if a configuration resource contains the following property
 definitions: 
 <pre><code>
  &lt;property&gt;
    &lt;name&gt;basedir&lt;/name&gt;
    &lt;value&gt;/user/${<i>user.name</i>}&lt;/value&gt;
  &lt;/property&gt;
  
  &lt;property&gt;
    &lt;name&gt;tempdir&lt;/name&gt;
    &lt;value&gt;${<i>basedir</i>}/tmp&lt;/value&gt;
  &lt;/property&gt;

  &lt;property&gt;
    &lt;name&gt;otherdir&lt;/name&gt;
    &lt;value&gt;${<i>env.BASE_DIR</i>}/other&lt;/value&gt;
  &lt;/property&gt;
  </code></pre>

 <p>When <tt>conf.get("tempdir")</tt> is called, then <tt>${<i>basedir</i>}</tt>
 will be resolved to another property in this Configuration, while
 <tt>${<i>user.name</i>}</tt> would then ordinarily be resolved to the value
 of the System property with that name.
 <p>When <tt>conf.get("otherdir")</tt> is called, then <tt>${<i>env.BASE_DIR</i>}</tt>
 will be resolved to the value of the <tt>${<i>BASE_DIR</i>}</tt> environment variable.
 It supports <tt>${<i>env.NAME:-default</i>}</tt> and <tt>${<i>env.NAME-default</i>}</tt> notations.
 The former is resolved to "default" if <tt>${<i>NAME</i>}</tt> environment variable is undefined
 or its value is empty.
 The latter behaves the same way only if <tt>${<i>NAME</i>}</tt> is undefined.
 <p>By default, warnings will be given to any deprecated configuration 
 parameters and these are suppressible by configuring
 <tt>log4j.logger.org.apache.hadoop.conf.Configuration.deprecation</tt> in
 log4j.properties file.

 <h4 id="Tags">Tags</h4>

 <p>Optionally we can tag related properties together by using tag
 attributes. System tags are defined by hadoop.tags.system property. Users
 can define there own custom tags in  hadoop.tags.custom property.

 <p>For example, we can tag existing property as:
 <pre><code>
  &lt;property&gt;
    &lt;name&gt;dfs.replication&lt;/name&gt;
    &lt;value&gt;3&lt;/value&gt;
    &lt;tag&gt;HDFS,REQUIRED&lt;/tag&gt;
  &lt;/property&gt;

  &lt;property&gt;
    &lt;name&gt;dfs.data.transfer.protection&lt;/name&gt;
    &lt;value&gt;3&lt;/value&gt;
    &lt;tag&gt;HDFS,SECURITY&lt;/tag&gt;
  &lt;/property&gt;
 </code></pre>
 <p> Properties marked with tags can be retrieved with <tt>conf
 .getAllPropertiesByTag("HDFS")</tt> or <tt>conf.getAllPropertiesByTags
 (Arrays.asList("YARN","SECURITY"))</tt>.</p>]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.conf.Configuration -->
  <!-- start class org.apache.hadoop.conf.Configured -->
  <class name="Configured" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <constructor name="Configured"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a Configured.]]>
      </doc>
    </constructor>
    <constructor name="Configured" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a Configured.]]>
      </doc>
    </constructor>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Base class for things that may be configured with a {@link Configuration}.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.conf.Configured -->
  <doc>
  <![CDATA[Configuration of system parameters.]]>
  </doc>
</package>
<package name="org.apache.hadoop.crypto">
</package>
<package name="org.apache.hadoop.crypto.key">
  <!-- start class org.apache.hadoop.crypto.key.KeyProvider -->
  <class name="KeyProvider" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <constructor name="KeyProvider" type="org.apache.hadoop.conf.Configuration"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor.
 
 @param conf configuration for the provider]]>
      </doc>
    </constructor>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the provider configuration.
 
 @return the provider configuration]]>
      </doc>
    </method>
    <method name="options" return="org.apache.hadoop.crypto.key.KeyProvider.Options"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[A helper function to create an options object.
 @param conf the configuration to use
 @return a new options object]]>
      </doc>
    </method>
    <method name="isTransient" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Indicates whether this provider represents a store
 that is intended for transient use - such as the UserProvider
 is. These providers are generally used to provide access to
 keying material rather than for long term storage.
 @return true if transient, false otherwise]]>
      </doc>
    </method>
    <method name="getKeyVersion" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="versionName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the key material for a specific version of the key. This method is used
 when decrypting data.
 @param versionName the name of a specific version of the key
 @return the key material
 @throws IOException]]>
      </doc>
    </method>
    <method name="getKeys" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the key names for all keys.
 @return the list of key names
 @throws IOException]]>
      </doc>
    </method>
    <method name="getKeysMetadata" return="org.apache.hadoop.crypto.key.KeyProvider.Metadata[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="names" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get key metadata in bulk.
 @param names the names of the keys to get
 @throws IOException]]>
      </doc>
    </method>
    <method name="getKeyVersions" return="java.util.List"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the key material for all versions of a specific key name.
 @return the list of key material
 @throws IOException]]>
      </doc>
    </method>
    <method name="getCurrentKey" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the current version of the key, which should be used for encrypting new
 data.
 @param name the base name of the key
 @return the version name of the current version of the key or null if the
    key version doesn't exist
 @throws IOException]]>
      </doc>
    </method>
    <method name="getMetadata" return="org.apache.hadoop.crypto.key.KeyProvider.Metadata"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get metadata about the key.
 @param name the basename of the key
 @return the key's metadata or null if the key doesn't exist
 @throws IOException]]>
      </doc>
    </method>
    <method name="createKey" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="material" type="byte[]"/>
      <param name="options" type="org.apache.hadoop.crypto.key.KeyProvider.Options"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a new key. The given key must not already exist.
 @param name the base name of the key
 @param material the key material for the first version of the key.
 @param options the options for the new key.
 @return the version name of the first version of the key.
 @throws IOException]]>
      </doc>
    </method>
    <method name="generateKey" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="size" type="int"/>
      <param name="algorithm" type="java.lang.String"/>
      <exception name="NoSuchAlgorithmException" type="java.security.NoSuchAlgorithmException"/>
      <doc>
      <![CDATA[Generates a key material.

 @param size length of the key.
 @param algorithm algorithm to use for generating the key.
 @return the generated key.
 @throws NoSuchAlgorithmException]]>
      </doc>
    </method>
    <method name="createKey" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="options" type="org.apache.hadoop.crypto.key.KeyProvider.Options"/>
      <exception name="NoSuchAlgorithmException" type="java.security.NoSuchAlgorithmException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a new key generating the material for it.
 The given key must not already exist.
 <p>
 This implementation generates the key material and calls the
 {@link #createKey(String, byte[], Options)} method.

 @param name the base name of the key
 @param options the options for the new key.
 @return the version name of the first version of the key.
 @throws IOException
 @throws NoSuchAlgorithmException]]>
      </doc>
    </method>
    <method name="deleteKey"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Delete the given key.
 @param name the name of the key to delete
 @throws IOException]]>
      </doc>
    </method>
    <method name="rollNewVersion" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="material" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Roll a new version of the given key.
 @param name the basename of the key
 @param material the new key material
 @return the name of the new version of the key
 @throws IOException]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Can be used by implementing classes to close any resources
 that require closing]]>
      </doc>
    </method>
    <method name="rollNewVersion" return="org.apache.hadoop.crypto.key.KeyProvider.KeyVersion"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="NoSuchAlgorithmException" type="java.security.NoSuchAlgorithmException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Roll a new version of the given key generating the material for it.
 <p>
 This implementation generates the key material and calls the
 {@link #rollNewVersion(String, byte[])} method.

 @param name the basename of the key
 @return the name of the new version of the key
 @throws IOException]]>
      </doc>
    </method>
    <method name="invalidateCache"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Can be used by implementing classes to invalidate the caches. This could be
 used after rollNewVersion to provide a strong guarantee to return the new
 version of the given key.

 @param name the basename of the key
 @throws IOException]]>
      </doc>
    </method>
    <method name="flush"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Ensures that any changes to the keys are written to persistent store.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getBaseName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="versionName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Split the versionName in to a base name. Converts "/aaa/bbb/3" to
 "/aaa/bbb".
 @param versionName the version name to split
 @return the base name of the key
 @throws IOException]]>
      </doc>
    </method>
    <method name="buildVersionName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="version" type="int"/>
      <doc>
      <![CDATA[Build a version string from a basename and version number. Converts
 "/aaa/bbb" and 3 to "/aaa/bbb@3".
 @param name the basename of the key
 @param version the version of the key
 @return the versionName of the key.]]>
      </doc>
    </method>
    <method name="findProvider" return="org.apache.hadoop.crypto.key.KeyProvider"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerList" type="java.util.List"/>
      <param name="keyName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Find the provider with the given key.
 @param providerList the list of providers
 @param keyName the key name we are looking for
 @return the KeyProvider that has the key]]>
      </doc>
    </method>
    <method name="needsPassword" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Does this provider require a password? This means that a password is
 required for normal operation, and it has not been found through normal
 means. If true, the password should be provided by the caller using
 setPassword().
 @return Whether or not the provider requires a password
 @throws IOException]]>
      </doc>
    </method>
    <method name="noPasswordWarning" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If a password for the provider is needed, but is not provided, this will
 return a warning and instructions for supplying said password to the
 provider.
 @return A warning and instructions for supplying the password]]>
      </doc>
    </method>
    <method name="noPasswordError" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[If a password for the provider is needed, but is not provided, this will
 return an error message and instructions for supplying said password to
 the provider.
 @return An error message and instructions for supplying the password]]>
      </doc>
    </method>
    <field name="DEFAULT_CIPHER_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_CIPHER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_BITLENGTH_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DEFAULT_BITLENGTH" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="JCEKS_KEY_SERIALFILTER_DEFAULT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="JCEKS_KEY_SERIAL_FILTER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A provider of secret key material for Hadoop applications. Provides an
 abstraction to separate key storage from users of encryption. It
 is intended to support getting or storing keys in a variety of ways,
 including third party bindings.
 <p>
 <code>KeyProvider</code> implementations must be thread safe.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.KeyProvider -->
  <!-- start class org.apache.hadoop.crypto.key.KeyProviderFactory -->
  <class name="KeyProviderFactory" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="KeyProviderFactory"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createProvider" return="org.apache.hadoop.crypto.key.KeyProvider"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="providerName" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getProviders" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="get" return="org.apache.hadoop.crypto.key.KeyProvider"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a KeyProvider based on a provided URI.

 @param uri key provider URI
 @param conf configuration to initialize the key provider
 @return the key provider for the specified URI, or <code>NULL</code> if
         a provider for the specified URI scheme could not be found.
 @throws IOException thrown if the provider failed to initialize.]]>
      </doc>
    </method>
    <field name="KEY_PROVIDER_PATH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A factory to create a list of KeyProvider based on the path given in a
 Configuration. It uses a service loader interface to find the available
 KeyProviders and create them based on the list of URIs.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.crypto.key.KeyProviderFactory -->
</package>
<package name="org.apache.hadoop.crypto.key.kms">
</package>
<package name="org.apache.hadoop.crypto.random">
</package>
<package name="org.apache.hadoop.fs">
  <!-- start interface org.apache.hadoop.fs.Abortable -->
  <interface name="Abortable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="abort" return="org.apache.hadoop.fs.Abortable.AbortableResult"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Abort the active operation without the output becoming visible.

 This is to provide ability to cancel the write on stream; once
 a stream is aborted, the write MUST NOT become visible.

 @throws UnsupportedOperationException if the operation is not supported.
 @return the result.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Abort data being written to  a stream, so that close() does
  not write the data. It is implemented by output streams in
  some object stores, and passed through {@link FSDataOutputStream}.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.Abortable -->
  <!-- start class org.apache.hadoop.fs.AbstractFileSystem -->
  <class name="AbstractFileSystem" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.fs.PathCapabilities"/>
    <constructor name="AbstractFileSystem" type="java.net.URI, java.lang.String, boolean, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="URISyntaxException" type="java.net.URISyntaxException"/>
      <doc>
      <![CDATA[Constructor to be called by subclasses.
 
 @param uri for this file system.
 @param supportedScheme the scheme supported by the implementor
 @param authorityNeeded if true then theURI must have authority, if false
          then the URI must have null authority.

 @throws URISyntaxException <code>uri</code> has syntax error]]>
      </doc>
    </constructor>
    <method name="getStatistics" return="org.apache.hadoop.fs.FileSystem.Statistics"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="isValidName" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns true if the specified string is considered valid in the path part
 of a URI by this file system.  The default implementation enforces the rules
 of HDFS, but subclasses may override this method to implement specific
 validation rules for specific file systems.
 
 @param src String source filename to check, path part of the URI
 @return boolean true if the specified string is considered valid]]>
      </doc>
    </method>
    <method name="createFileSystem" return="org.apache.hadoop.fs.AbstractFileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <doc>
      <![CDATA[Create a file system instance for the specified uri using the conf. The
 conf is used to find the class name that implements the file system. The
 conf is also passed to the file system for its configuration.

 @param uri URI of the file system
 @param conf Configuration for the file system
 
 @return Returns the file system for the given URI

 @throws UnsupportedFileSystemException file system for <code>uri</code> is
           not found]]>
      </doc>
    </method>
    <method name="getStatistics" return="org.apache.hadoop.fs.FileSystem.Statistics"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <doc>
      <![CDATA[Get the statistics for a particular file system.
 
 @param uri
          used as key to lookup STATISTICS_TABLE. Only scheme and authority
          part of the uri are used.
 @return a statistics object]]>
      </doc>
    </method>
    <method name="clearStatistics"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="printStatistics"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Prints statistics for all file systems.]]>
      </doc>
    </method>
    <method name="getAllStatistics" return="java.util.Map"
      abstract="false" native="false" synchronized="true"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="get" return="org.apache.hadoop.fs.AbstractFileSystem"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <doc>
      <![CDATA[The main factory method for creating a file system. Get a file system for
 the URI's scheme and authority. The scheme of the <code>uri</code>
 determines a configuration property name,
 <tt>fs.AbstractFileSystem.<i>scheme</i>.impl</tt> whose value names the
 AbstractFileSystem class.
 
 The entire URI and conf is passed to the AbstractFileSystem factory method.
 
 @param uri for the file system to be created.
 @param conf which is passed to the file system impl.
 
 @return file system for the given URI.
 
 @throws UnsupportedFileSystemException if the file system for
           <code>uri</code> is not supported.]]>
      </doc>
    </method>
    <method name="checkScheme"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="supportedScheme" type="java.lang.String"/>
      <doc>
      <![CDATA[Check that the Uri's scheme matches
 @param uri
 @param supportedScheme]]>
      </doc>
    </method>
    <method name="getUriDefaultPort" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The default port of this file system.
 
 @return default port of this file system's Uri scheme
         A uri with a port of -1 =&gt; default port;]]>
      </doc>
    </method>
    <method name="getUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a URI whose scheme and authority identify this FileSystem.
 
 @return the uri of this file system.]]>
      </doc>
    </method>
    <method name="checkPath"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Check that a Path belongs to this FileSystem.
 
 If the path is fully qualified URI, then its scheme and authority
 matches that of this file system. Otherwise the path must be 
 slash-relative name.
 
 @throws InvalidPathException if the path is invalid]]>
      </doc>
    </method>
    <method name="getUriPath" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Get the path-part of a pathname. Checks that URI matches this file system
 and that the path-part is a valid name.
 
 @param p path
 
 @return path-part of the Path p]]>
      </doc>
    </method>
    <method name="makeQualified" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Make the path fully qualified to this file system
 @param path
 @return the qualified path]]>
      </doc>
    </method>
    <method name="getInitialWorkingDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Some file systems like LocalFileSystem have an initial workingDir
 that is used as the starting workingDir. For other file systems
 like HDFS there is no built in notion of an initial workingDir.
 
 @return the initial workingDir if the file system has such a notion
         otherwise return a null.]]>
      </doc>
    </method>
    <method name="getHomeDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the current user's home directory in this file system.
 The default implementation returns "/user/$USER/".
 
 @return current user's home directory.]]>
      </doc>
    </method>
    <method name="getServerDefaults" return="org.apache.hadoop.fs.FsServerDefaults"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="use {@link #getServerDefaults(Path)} instead">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return a set of server default configuration values.
 
 @return server default configuration values
 
 @throws IOException an I/O error occurred
 @deprecated use {@link #getServerDefaults(Path)} instead]]>
      </doc>
    </method>
    <method name="getServerDefaults" return="org.apache.hadoop.fs.FsServerDefaults"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return a set of server default configuration values based on path.
 @param f path to fetch server defaults
 @return server default configuration values for path
 @throws IOException an I/O error occurred]]>
      </doc>
    </method>
    <method name="resolvePath" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Return the fully-qualified path of path f resolving the path
 through any internal symlinks or mount point
 @param p path to be resolved
 @return fully qualified path 
 @throws FileNotFoundException
 @throws AccessControlException
 @throws IOException
 @throws UnresolvedLinkException if symbolic link on path cannot be
 resolved internally]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="createFlag" type="java.util.EnumSet"/>
      <param name="opts" type="org.apache.hadoop.fs.Options.CreateOpts[]"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#create(Path, EnumSet, Options.CreateOpts...)} except
 that the Path f must be fully qualified and the permission is absolute
 (i.e. umask has been applied).]]>
      </doc>
    </method>
    <method name="createInternal" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="flag" type="java.util.EnumSet"/>
      <param name="absolutePermission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <param name="checksumOpt" type="org.apache.hadoop.fs.Options.ChecksumOpt"/>
      <param name="createParent" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link #create(Path, EnumSet, Options.CreateOpts...)} except that the opts
 have been declared explicitly.]]>
      </doc>
    </method>
    <method name="mkdir"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dir" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="createParent" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#mkdir(Path, FsPermission, boolean)} except that the Path
 f must be fully qualified and the permission is absolute (i.e. 
 umask has been applied).]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="recursive" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#delete(Path, boolean)} except that Path f must be for
 this file system.]]>
      </doc>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#open(Path)} except that Path f must be for this
 file system.]]>
      </doc>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#open(Path, int)} except that Path f must be for this
 file system.]]>
      </doc>
    </method>
    <method name="truncate" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="newLength" type="long"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#truncate(Path, long)} except that Path f must be for
 this file system.]]>
      </doc>
    </method>
    <method name="setReplication" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="replication" type="short"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#setReplication(Path, short)} except that Path f must be
 for this file system.]]>
      </doc>
    </method>
    <method name="rename"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="options" type="org.apache.hadoop.fs.Options.Rename[]"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#rename(Path, Path, Options.Rename...)} except that Path
 f must be for this file system.]]>
      </doc>
    </method>
    <method name="renameInternal"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#rename(Path, Path, Options.Rename...)} except that Path
 f must be for this file system and NO OVERWRITE is performed.
 
 File systems that do not have a built in overwrite need implement only this
 method and can take advantage of the default impl of the other
 {@link #renameInternal(Path, Path, boolean)}]]>
      </doc>
    </method>
    <method name="renameInternal"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="overwrite" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileAlreadyExistsException" type="org.apache.hadoop.fs.FileAlreadyExistsException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="ParentNotDirectoryException" type="org.apache.hadoop.fs.ParentNotDirectoryException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#rename(Path, Path, Options.Rename...)} except that Path
 f must be for this file system.]]>
      </doc>
    </method>
    <method name="supportsSymlinks" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the file system supports symlinks, false otherwise.
 @return true if filesystem supports symlinks]]>
      </doc>
    </method>
    <method name="createSymlink"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="target" type="org.apache.hadoop.fs.Path"/>
      <param name="link" type="org.apache.hadoop.fs.Path"/>
      <param name="createParent" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <doc>
      <![CDATA[The specification of this method matches that of  
 {@link FileContext#createSymlink(Path, Path, boolean)};]]>
      </doc>
    </method>
    <method name="getLinkTarget" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Partially resolves the path. This is used during symlink resolution in
 {@link FSLinkResolver}, and differs from the similarly named method
 {@link FileContext#getLinkTarget(Path)}.
 @throws IOException subclass implementations may throw IOException]]>
      </doc>
    </method>
    <method name="setPermission"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#setPermission(Path, FsPermission)} except that Path f
 must be for this file system.]]>
      </doc>
    </method>
    <method name="setOwner"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="username" type="java.lang.String"/>
      <param name="groupname" type="java.lang.String"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#setOwner(Path, String, String)} except that Path f must
 be for this file system.]]>
      </doc>
    </method>
    <method name="setTimes"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="mtime" type="long"/>
      <param name="atime" type="long"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#setTimes(Path, long, long)} except that Path f must be
 for this file system.]]>
      </doc>
    </method>
    <method name="getFileChecksum" return="org.apache.hadoop.fs.FileChecksum"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#getFileChecksum(Path)} except that Path f must be for
 this file system.]]>
      </doc>
    </method>
    <method name="getFileStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#getFileStatus(Path)} 
 except that an UnresolvedLinkException may be thrown if a symlink is 
 encountered in the path.]]>
      </doc>
    </method>
    <method name="msync"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
      <doc>
      <![CDATA[Synchronize client metadata state.
 <p>
 In some FileSystem implementations such as HDFS metadata
 synchronization is essential to guarantee consistency of read requests
 particularly in HA setting.
 @throws IOException
 @throws UnsupportedOperationException]]>
      </doc>
    </method>
    <method name="getFileLinkStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnsupportedFileSystemException" type="org.apache.hadoop.fs.UnsupportedFileSystemException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#getFileLinkStatus(Path)}
 except that an UnresolvedLinkException may be thrown if a symlink is  
 encountered in the path leading up to the final path component.
 If the file system does not support symlinks then the behavior is
 equivalent to {@link AbstractFileSystem#getFileStatus(Path)}.]]>
      </doc>
    </method>
    <method name="getFileBlockLocations" return="org.apache.hadoop.fs.BlockLocation[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="start" type="long"/>
      <param name="len" type="long"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#getFileBlockLocations(Path, long, long)} except that
 Path f must be for this file system.]]>
      </doc>
    </method>
    <method name="getFsStatus" return="org.apache.hadoop.fs.FsStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#getFsStatus(Path)} except that Path f must be for this
 file system.]]>
      </doc>
    </method>
    <method name="getFsStatus" return="org.apache.hadoop.fs.FsStatus"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#getFsStatus(Path)}.]]>
      </doc>
    </method>
    <method name="listStatusIterator" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#listStatus(Path)} except that Path f must be for this
 file system.]]>
      </doc>
    </method>
    <method name="listLocatedStatus" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#listLocatedStatus(Path)} except that Path f 
 must be for this file system.

 In HDFS implementation, the BlockLocation of returned LocatedFileStatus
 will have different formats for replicated and erasure coded file. Please
 refer to {@link FileSystem#getFileBlockLocations(FileStatus, long, long)}
 for more details.]]>
      </doc>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="UnresolvedLinkException" type="org.apache.hadoop.fs.UnresolvedLinkException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext.Util#listStatus(Path)} except that Path f must be 
 for this file system.]]>
      </doc>
    </method>
    <method name="listCorruptFileBlocks" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[@return an iterator over the corrupt files under the given path
 (may contain duplicates if a file has more than one corrupt block)
 @throws IOException]]>
      </doc>
    </method>
    <method name="setVerifyChecksum"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="verifyChecksum" type="boolean"/>
      <exception name="AccessControlException" type="org.apache.hadoop.security.AccessControlException"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#setVerifyChecksum(boolean, Path)} except that Path f
 must be for this file system.]]>
      </doc>
    </method>
    <method name="getCanonicalServiceName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a canonical name for this file system.
 @return a URI string that uniquely identifies this file system]]>
      </doc>
    </method>
    <method name="modifyAclEntries"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Modifies ACL entries of files and directories.  This method can add new ACL
 entries or modify the permissions on existing ACL entries.  All existing
 ACL entries that are not specified in this call are retained without
 changes.  (Modifications are merged into the current ACL.)

 @param path Path to modify
 @param aclSpec List{@literal <AclEntry>} describing modifications
 @throws IOException if an ACL could not be modified]]>
      </doc>
    </method>
    <method name="removeAclEntries"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Removes ACL entries from files and directories.  Other ACL entries are
 retained.

 @param path Path to modify
 @param aclSpec List{@literal <AclEntry>} describing entries to remove
 @throws IOException if an ACL could not be modified]]>
      </doc>
    </method>
    <method name="removeDefaultAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Removes all default ACL entries from files and directories.

 @param path Path to modify
 @throws IOException if an ACL could not be modified]]>
      </doc>
    </method>
    <method name="removeAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Removes all but the base ACL entries of files and directories.  The entries
 for user, group, and others are retained for compatibility with permission
 bits.

 @param path Path to modify
 @throws IOException if an ACL could not be removed]]>
      </doc>
    </method>
    <method name="setAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Fully replaces ACL of files and directories, discarding all existing
 entries.

 @param path Path to modify
 @param aclSpec List{@literal <AclEntry>} describing modifications, must
 include entries for user, group, and others for compatibility with
 permission bits.
 @throws IOException if an ACL could not be modified]]>
      </doc>
    </method>
    <method name="getAclStatus" return="org.apache.hadoop.fs.permission.AclStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Gets the ACLs of files and directories.

 @param path Path to get
 @return RemoteIterator{@literal <AclStatus>} which returns each AclStatus
 @throws IOException if an ACL could not be read]]>
      </doc>
    </method>
    <method name="setXAttr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <param name="value" type="byte[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set an xattr of a file or directory.
 The name must be prefixed with the namespace followed by ".". For example,
 "user.attr".
 <p>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to modify
 @param name xattr name.
 @param value xattr value.
 @throws IOException]]>
      </doc>
    </method>
    <method name="setXAttr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <param name="value" type="byte[]"/>
      <param name="flag" type="java.util.EnumSet"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set an xattr of a file or directory.
 The name must be prefixed with the namespace followed by ".". For example,
 "user.attr".
 <p>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to modify
 @param name xattr name.
 @param value xattr value.
 @param flag xattr set flag
 @throws IOException]]>
      </doc>
    </method>
    <method name="getXAttr" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get an xattr for a file or directory.
 The name must be prefixed with the namespace followed by ".". For example,
 "user.attr".
 <p>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to get extended attribute
 @param name xattr name.
 @return byte[] xattr value.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getXAttrs" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get all of the xattrs for a file or directory.
 Only those xattrs for which the logged-in user has permissions to view
 are returned.
 <p>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to get extended attributes

 @return {@literal Map<String, byte[]>} describing the XAttrs of the file
 or directory
 @throws IOException]]>
      </doc>
    </method>
    <method name="getXAttrs" return="java.util.Map"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="names" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get all of the xattrs for a file or directory.
 Only those xattrs for which the logged-in user has permissions to view
 are returned.
 <p>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to get extended attributes
 @param names XAttr names.
 @return {@literal Map<String, byte[]>} describing the XAttrs of the file
 or directory
 @throws IOException]]>
      </doc>
    </method>
    <method name="listXAttrs" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get all of the xattr names for a file or directory.
 Only the xattr names for which the logged-in user has permissions to view
 are returned.
 <p>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to get extended attributes
 @return {@literal Map<String, byte[]>} describing the XAttrs of the file
 or directory
 @throws IOException]]>
      </doc>
    </method>
    <method name="removeXAttr"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="name" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Remove an xattr of a file or directory.
 The name must be prefixed with the namespace followed by ".". For example,
 "user.attr".
 <p>
 Refer to the HDFS extended attributes user documentation for details.

 @param path Path to remove extended attribute
 @param name xattr name
 @throws IOException]]>
      </doc>
    </method>
    <method name="createSnapshot" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="snapshotName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#createSnapshot(Path, String)}.]]>
      </doc>
    </method>
    <method name="renameSnapshot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="snapshotOldName" type="java.lang.String"/>
      <param name="snapshotNewName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#renameSnapshot(Path, String, String)}.]]>
      </doc>
    </method>
    <method name="deleteSnapshot"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="snapshotDir" type="org.apache.hadoop.fs.Path"/>
      <param name="snapshotName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The specification of this method matches that of
 {@link FileContext#deleteSnapshot(Path, String)}.]]>
      </doc>
    </method>
    <method name="satisfyStoragePolicy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set the source path to satisfy storage policy.
 @param path The source path referring to either a directory or a file.
 @throws IOException]]>
      </doc>
    </method>
    <method name="setStoragePolicy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="policyName" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set the storage policy for a given file or directory.

 @param path file or directory path.
 @param policyName the name of the target storage policy. The list
                   of supported Storage policies can be retrieved
                   via {@link #getAllStoragePolicies}.]]>
      </doc>
    </method>
    <method name="unsetStoragePolicy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Unset the storage policy set for a given file or directory.
 @param src file or directory path.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getStoragePolicy" return="org.apache.hadoop.fs.BlockStoragePolicySpi"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Retrieve the storage policy for a given file or directory.

 @param src file or directory path.
 @return storage policy for give file.
 @throws IOException]]>
      </doc>
    </method>
    <method name="getAllStoragePolicies" return="java.util.Collection"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Retrieve all the storage policies supported by this file system.

 @return all storage policies supported by this filesystem.
 @throws IOException]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
    </method>
    <method name="openFileWithOptions" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="parameters" type="org.apache.hadoop.fs.impl.OpenFileParameters"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Open a file with the given set of options.
 The base implementation performs a blocking
 call to {@link #open(Path, int)}in this call;
 the actual outcome is in the returned {@code CompletableFuture}.
 This avoids having to create some thread pool, while still
 setting up the expectation that the {@code get()} call
 is needed to evaluate the result.
 @param path path to the file
 @param parameters open file parameters from the builder.
 @return a future which will evaluate to the opened file.
 @throws IOException failure to resolve the link.
 @throws IllegalArgumentException unknown mandatory key]]>
      </doc>
    </method>
    <method name="hasPathCapability" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="capability" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createMultipartUploader" return="org.apache.hadoop.fs.MultipartUploaderBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="basePath" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Create a multipart uploader.
 @param basePath file path under which all files are uploaded
 @return a MultipartUploaderBuilder object to build the uploader
 @throws IOException if some early checks cause IO failures.
 @throws UnsupportedOperationException if support is checked early.]]>
      </doc>
    </method>
    <method name="methodNotSupported"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Helper method that throws an {@link UnsupportedOperationException} for the
 current {@link FileSystem} method being called.]]>
      </doc>
    </method>
    <field name="statistics" type="org.apache.hadoop.fs.FileSystem.Statistics"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The statistics for this file system.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[This class provides an interface for implementors of a Hadoop file system
 (analogous to the VFS of Unix). Applications do not access this class;
 instead they access files across all file systems using {@link FileContext}.
 
 Pathnames passed to AbstractFileSystem can be fully qualified URI that
 matches the "this" file system (ie same scheme and authority) 
 or a Slash-relative name that is assumed to be relative
 to the root of the "this" file system .]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.AbstractFileSystem -->
  <!-- start class org.apache.hadoop.fs.AvroFSInput -->
  <class name="AvroFSInput" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <implements name="org.apache.avro.file.SeekableInput"/>
    <constructor name="AvroFSInput" type="org.apache.hadoop.fs.FSDataInputStream, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct given an {@link FSDataInputStream} and its length.]]>
      </doc>
    </constructor>
    <constructor name="AvroFSInput" type="org.apache.hadoop.fs.FileContext, org.apache.hadoop.fs.Path"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Construct given a {@link FileContext} and a {@link Path}.]]>
      </doc>
    </constructor>
    <method name="length" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="read" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="b" type="byte[]"/>
      <param name="off" type="int"/>
      <param name="len" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="seek"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="tell" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Adapts an {@link FSDataInputStream} to Avro's SeekableInput interface.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.AvroFSInput -->
  <!-- start interface org.apache.hadoop.fs.BatchListingOperations -->
  <interface name="BatchListingOperations"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="batchedListStatusIterator" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="paths" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Batched listing API that returns {@link PartialListing}s for the
 passed Paths.

 @param paths List of paths to list.
 @return RemoteIterator that returns corresponding PartialListings.
 @throws IOException failure]]>
      </doc>
    </method>
    <method name="batchedListLocatedStatusIterator" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="paths" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Batched listing API that returns {@link PartialListing}s for the passed
 Paths. The PartialListing will contain {@link LocatedFileStatus} entries
 with locations.

 @param paths List of paths to list.
 @return RemoteIterator that returns corresponding PartialListings.
 @throws IOException failure]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface filesystems MAY implement to offer a batched list.
 If implemented, filesystems SHOULD declare
 {@link CommonPathCapabilities#FS_EXPERIMENTAL_BATCH_LISTING} to be a supported
 path capability.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.BatchListingOperations -->
  <!-- start class org.apache.hadoop.fs.BlockLocation -->
  <class name="BlockLocation" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Serializable"/>
    <constructor name="BlockLocation"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default Constructor.]]>
      </doc>
    </constructor>
    <constructor name="BlockLocation" type="org.apache.hadoop.fs.BlockLocation"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Copy constructor.]]>
      </doc>
    </constructor>
    <constructor name="BlockLocation" type="java.lang.String[], java.lang.String[], long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor with host, name, offset and length.]]>
      </doc>
    </constructor>
    <constructor name="BlockLocation" type="java.lang.String[], java.lang.String[], long, long, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor with host, name, offset, length and corrupt flag.]]>
      </doc>
    </constructor>
    <constructor name="BlockLocation" type="java.lang.String[], java.lang.String[], java.lang.String[], long, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor with host, name, network topology, offset and length.]]>
      </doc>
    </constructor>
    <constructor name="BlockLocation" type="java.lang.String[], java.lang.String[], java.lang.String[], long, long, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructor with host, name, network topology, offset, length 
 and corrupt flag.]]>
      </doc>
    </constructor>
    <constructor name="BlockLocation" type="java.lang.String[], java.lang.String[], java.lang.String[], java.lang.String[], long, long, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="BlockLocation" type="java.lang.String[], java.lang.String[], java.lang.String[], java.lang.String[], java.lang.String[], org.apache.hadoop.fs.StorageType[], long, long, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getHosts" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the list of hosts (hostname) hosting this block.]]>
      </doc>
    </method>
    <method name="getCachedHosts" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the list of hosts (hostname) hosting a cached replica of the block.]]>
      </doc>
    </method>
    <method name="getNames" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the list of names (IP:xferPort) hosting this block.]]>
      </doc>
    </method>
    <method name="getTopologyPaths" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Get the list of network topology paths for each of the hosts.
 The last component of the path is the "name" (IP:xferPort).]]>
      </doc>
    </method>
    <method name="getStorageIds" return="java.lang.String[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the storageID of each replica of the block.]]>
      </doc>
    </method>
    <method name="getStorageTypes" return="org.apache.hadoop.fs.StorageType[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the storage type of each replica of the block.]]>
      </doc>
    </method>
    <method name="getOffset" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the start offset of file associated with this block.]]>
      </doc>
    </method>
    <method name="getLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the length of the block.]]>
      </doc>
    </method>
    <method name="isCorrupt" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the corrupt flag.]]>
      </doc>
    </method>
    <method name="isStriped" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return true if the block is striped (erasure coded).]]>
      </doc>
    </method>
    <method name="setOffset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="offset" type="long"/>
      <doc>
      <![CDATA[Set the start offset of file associated with this block.]]>
      </doc>
    </method>
    <method name="setLength"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="length" type="long"/>
      <doc>
      <![CDATA[Set the length of block.]]>
      </doc>
    </method>
    <method name="setCorrupt"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="corrupt" type="boolean"/>
      <doc>
      <![CDATA[Set the corrupt flag.]]>
      </doc>
    </method>
    <method name="setHosts"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hosts" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set the hosts hosting this block.]]>
      </doc>
    </method>
    <method name="setCachedHosts"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="cachedHosts" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Set the hosts hosting a cached replica of this block.]]>
      </doc>
    </method>
    <method name="setNames"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="names" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set the names (host:port) hosting this block.]]>
      </doc>
    </method>
    <method name="setTopologyPaths"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="topologyPaths" type="java.lang.String[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set the network topology paths of the hosts.]]>
      </doc>
    </method>
    <method name="setStorageIds"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="storageIds" type="java.lang.String[]"/>
    </method>
    <method name="setStorageTypes"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="storageTypes" type="org.apache.hadoop.fs.StorageType[]"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents the network location of a block, information about the hosts
 that contain block replicas, and other block metadata (E.g. the file
 offset associated with the block, length, whether it is corrupt, etc).

 For a single BlockLocation, it will have different meanings for replicated
 and erasure coded files.

 If the file is 3-replicated, offset and length of a BlockLocation represent
 the absolute value in the file and the hosts are the 3 datanodes that
 holding the replicas. Here is an example:
 <pre>
 BlockLocation(offset: 0, length: BLOCK_SIZE,
   hosts: {"host1:9866", "host2:9866, host3:9866"})
 </pre>

 And if the file is erasure-coded, each BlockLocation represents a logical
 block groups. Value offset is the offset of a block group in the file and
 value length is the total length of a block group. Hosts of a BlockLocation
 are the datanodes that holding all the data blocks and parity blocks of a
 block group.
 Suppose we have a RS_3_2 coded file (3 data units and 2 parity units).
 A BlockLocation example will be like:
 <pre>
 BlockLocation(offset: 0, length: 3 * BLOCK_SIZE, hosts: {"host1:9866",
   "host2:9866","host3:9866","host4:9866","host5:9866"})
 </pre>

 Please refer to
 {@link FileSystem#getFileBlockLocations(FileStatus, long, long)} or
 {@link FileContext#getFileBlockLocations(Path, long, long)}
 for more examples.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.BlockLocation -->
  <!-- start interface org.apache.hadoop.fs.BlockStoragePolicySpi -->
  <interface name="BlockStoragePolicySpi"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getName" return="java.lang.String"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the name of the storage policy. Policies are uniquely
 identified by name.

 @return the name of the storage policy.]]>
      </doc>
    </method>
    <method name="getStorageTypes" return="org.apache.hadoop.fs.StorageType[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the preferred storage types associated with this policy. These
 storage types are used sequentially for successive block replicas.

 @return preferred storage types used for placing block replicas.]]>
      </doc>
    </method>
    <method name="getCreationFallbacks" return="org.apache.hadoop.fs.StorageType[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the fallback storage types for creating new block replicas. Fallback
 storage types are used if the preferred storage types are not available.

 @return fallback storage types for new block replicas..]]>
      </doc>
    </method>
    <method name="getReplicationFallbacks" return="org.apache.hadoop.fs.StorageType[]"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the fallback storage types for replicating existing block replicas.
 Fallback storage types are used if the preferred storage types are not
 available.

 @return fallback storage types for replicating existing block replicas.]]>
      </doc>
    </method>
    <method name="isCopyOnCreateFile" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if the policy is inherit-only and cannot be changed for
 an existing file.

 @return true if the policy is inherit-only.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A storage policy specifies the placement of block replicas on specific
 storage types.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.BlockStoragePolicySpi -->
  <!-- start interface org.apache.hadoop.fs.ByteBufferPositionedReadable -->
  <interface name="ByteBufferPositionedReadable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="read" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <param name="buf" type="java.nio.ByteBuffer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads up to {@code buf.remaining()} bytes into buf from a given position
 in the file and returns the number of bytes read. Callers should use
 {@code buf.limit(...)} to control the size of the desired read and
 {@code buf.position(...)} to control the offset into the buffer the data
 should be written to.
 <p>
 After a successful call, {@code buf.position()} will be advanced by the
 number of bytes read and {@code buf.limit()} will be unchanged.
 <p>
 In the case of an exception, the state of the buffer (the contents of the
 buffer, the {@code buf.position()}, the {@code buf.limit()}, etc.) is
 undefined, and callers should be prepared to recover from this
 eventuality.
 <p>
 Callers should use {@link StreamCapabilities#hasCapability(String)} with
 {@link StreamCapabilities#PREADBYTEBUFFER} to check if the underlying
 stream supports this interface, otherwise they might get a
 {@link UnsupportedOperationException}.
 <p>
 Implementations should treat 0-length requests as legitimate, and must not
 signal an error upon their receipt.
 <p>
 This does not change the current offset of a file, and is thread-safe.

 @param position position within file
 @param buf the ByteBuffer to receive the results of the read operation.
 @return the number of bytes read, possibly zero, or -1 if reached
         end-of-stream
 @throws IOException if there is some error performing the read]]>
      </doc>
    </method>
    <method name="readFully"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="position" type="long"/>
      <param name="buf" type="java.nio.ByteBuffer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads {@code buf.remaining()} bytes into buf from a given position in
 the file or until the end of the data was reached before the read
 operation completed. Callers should use {@code buf.limit(...)} to
 control the size of the desired read and {@code buf.position(...)} to
 control the offset into the buffer the data should be written to.
 <p>
 This operation provides similar semantics to
 {@link #read(long, ByteBuffer)}, the difference is that this method is
 guaranteed to read data until the {@link ByteBuffer} is full, or until
 the end of the data stream is reached.

 @param position position within file
 @param buf the ByteBuffer to receive the results of the read operation.
 @throws IOException if there is some error performing the read
 @throws EOFException the end of the data was reached before
 the read operation completed
 @see #read(long, ByteBuffer)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implementers of this interface provide a positioned read API that writes to a
 {@link ByteBuffer} rather than a {@code byte[]}.

 @see PositionedReadable
 @see ByteBufferReadable]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.ByteBufferPositionedReadable -->
  <!-- start interface org.apache.hadoop.fs.ByteBufferReadable -->
  <interface name="ByteBufferReadable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="read" return="int"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="buf" type="java.nio.ByteBuffer"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Reads up to buf.remaining() bytes into buf. Callers should use
 buf.limit(..) to control the size of the desired read.
 <p>
 After a successful call, {@code buf.position()} will be advanced by the
 number of bytes read and {@code buf.limit()} will be unchanged.
 <p>
 In the case of an exception, the state of the buffer (the contents of the
 buffer, the {@code buf.position()}, the {@code buf.limit()}, etc.) is
 undefined, and callers should be prepared to recover from this
 eventuality.
 <p>
 Callers should use {@link StreamCapabilities#hasCapability(String)} with
 {@link StreamCapabilities#READBYTEBUFFER} to check if the underlying
 stream supports this interface, otherwise they might get a
 {@link UnsupportedOperationException}.
 <p>
 Implementations should treat 0-length requests as legitimate, and must not
 signal an error upon their receipt.

 @param buf
          the ByteBuffer to receive the results of the read operation.
 @return the number of bytes read, possibly zero, or -1 if 
         reach end-of-stream
 @throws IOException
           if there is some error performing the read]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Implementers of this interface provide a read API that writes to a
 ByteBuffer, not a byte[].]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.ByteBufferReadable -->
  <!-- start interface org.apache.hadoop.fs.CanSetDropBehind -->
  <interface name="CanSetDropBehind"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="setDropBehind"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dropCache" type="java.lang.Boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
      <doc>
      <![CDATA[Configure whether the stream should drop the cache.

 @param dropCache     Whether to drop the cache.  null means to use the
                      default value.
 @throws IOException  If there was an error changing the dropBehind
                      setting.
         UnsupportedOperationException  If this stream doesn't support
                                        setting the drop-behind.]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.apache.hadoop.fs.CanSetDropBehind -->
  <!-- start interface org.apache.hadoop.fs.CanSetReadahead -->
  <interface name="CanSetReadahead"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="setReadahead"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="readahead" type="java.lang.Long"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
      <doc>
      <![CDATA[Set the readahead on this stream.

 @param readahead     The readahead to use.  null means to use the default.
 @throws IOException  If there was an error changing the dropBehind
                      setting.
         UnsupportedOperationException  If this stream doesn't support
                                        setting readahead.]]>
      </doc>
    </method>
  </interface>
  <!-- end interface org.apache.hadoop.fs.CanSetReadahead -->
  <!-- start interface org.apache.hadoop.fs.CanUnbuffer -->
  <interface name="CanUnbuffer"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="unbuffer"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Reduce the buffering.  This will also free sockets and file descriptors
 held by the stream, if possible.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[FSDataInputStreams implement this interface to indicate that they can clear
 their buffers on request.]]>
    </doc>
  </interface>
  <!-- end interface org.apache.hadoop.fs.CanUnbuffer -->
  <!-- start class org.apache.hadoop.fs.ChecksumException -->
  <class name="ChecksumException" extends="java.io.IOException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ChecksumException" type="java.lang.String, long"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getPos" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Thrown for checksum errors.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.ChecksumException -->
  <!-- start class org.apache.hadoop.fs.ChecksumFileSystem -->
  <class name="ChecksumFileSystem" extends="org.apache.hadoop.fs.FilterFileSystem"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ChecksumFileSystem" type="org.apache.hadoop.fs.FileSystem"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getApproxChkSumLength" return="double"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="long"/>
    </method>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="setVerifyChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="verifyChecksum" type="boolean"/>
      <doc>
      <![CDATA[Set whether to verify checksum.]]>
      </doc>
    </method>
    <method name="setWriteChecksum"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="writeChecksum" type="boolean"/>
    </method>
    <method name="getRawFileSystem" return="org.apache.hadoop.fs.FileSystem"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[get the raw file system]]>
      </doc>
    </method>
    <method name="getChecksumFile" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Return the name of the checksum file associated with a file.]]>
      </doc>
    </method>
    <method name="isChecksumFile" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Return true iff file is a checksum file name.]]>
      </doc>
    </method>
    <method name="getChecksumFileLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="org.apache.hadoop.fs.Path"/>
      <param name="fileSize" type="long"/>
      <doc>
      <![CDATA[Return the length of the checksum file given the size of the 
 actual file.]]>
      </doc>
    </method>
    <method name="getBytesPerSum" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return the bytes Per Checksum]]>
      </doc>
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Opens an FSDataInputStream at the indicated Path.
 @param f the file name to open
 @param bufferSize the size of the buffer to be used.]]>
      </doc>
    </method>
    <method name="append" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="truncate" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="newLength" type="long"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="concat"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="psrcs" type="org.apache.hadoop.fs.Path[]"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getChecksumLength" return="long"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="size" type="long"/>
      <param name="bytesPerSum" type="int"/>
      <doc>
      <![CDATA[Calculated the length of the checksum file in bytes.
 @param size the length of the data file in bytes
 @param bytesPerSum the number of bytes in a checksum block
 @return the number of bytes in the checksum file]]>
      </doc>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createNonRecursive" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="flags" type="java.util.EnumSet"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <param name="checksumOpt" type="org.apache.hadoop.fs.Options.ChecksumOpt"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="createNonRecursive" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="flags" type="java.util.EnumSet"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setPermission"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setOwner"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="username" type="java.lang.String"/>
      <param name="groupname" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="modifyAclEntries"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="removeAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="removeAclEntries"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="aclSpec" type="java.util.List"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="removeDefaultAcl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setReplication" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="replication" type="short"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Set replication for an existing file.
 Implement the abstract <tt>setReplication</tt> of <tt>FileSystem</tt>
 @param src file name
 @param replication new replication
 @throws IOException
 @return true if successful;
         false if file does not exist or is a directory]]>
      </doc>
    </method>
    <method name="rename" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Rename files/dirs]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="recursive" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Implement the delete(Path, boolean) in checksum
 file system.]]>
      </doc>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[List the statuses of the files/directories in the given path if the path is
 a directory.
 
 @param f
          given path
 @return the statuses of the files/directories in the given path
 @throws IOException]]>
      </doc>
    </method>
    <method name="listStatusIterator" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="p" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="listLocatedStatus" return="org.apache.hadoop.fs.RemoteIterator"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[List the statuses of the files/directories in the given path if the path is
 a directory.
 
 @param f
          given path
 @return the statuses of the files/directories in the given patch
 @throws IOException]]>
      </doc>
    </method>
    <method name="mkdirs" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="copyFromLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="copyToLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="delSrc" type="boolean"/>
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is under FS, and the dst is on the local disk.
 Copy it from FS control to the local dst name.]]>
      </doc>
    </method>
    <method name="copyToLocalFile"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <param name="copyCrc" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[The src file is under FS, and the dst is on the local disk.
 Copy it from FS control to the local dst name.
 If src and dst are directories, the copyCrc parameter
 determines whether to copy CRC files.]]>
      </doc>
    </method>
    <method name="startLocalOutput" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fsOutputFile" type="org.apache.hadoop.fs.Path"/>
      <param name="tmpLocalFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="completeLocalOutput"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fsOutputFile" type="org.apache.hadoop.fs.Path"/>
      <param name="tmpLocalFile" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="reportChecksumFailure" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="in" type="org.apache.hadoop.fs.FSDataInputStream"/>
      <param name="inPos" type="long"/>
      <param name="sums" type="org.apache.hadoop.fs.FSDataInputStream"/>
      <param name="sumsPos" type="long"/>
      <doc>
      <![CDATA[Report a checksum error to the file system.
 @param f the file name containing the error
 @param in the stream open on the file
 @param inPos the position of the beginning of the bad data in the file
 @param sums the stream open on the checksum file
 @param sumsPos the position of the beginning of the bad data in the checksum file
 @return if retry is necessary]]>
      </doc>
    </method>
    <method name="openFile" return="org.apache.hadoop.fs.FutureDataInputStreamBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="UnsupportedOperationException" type="java.lang.UnsupportedOperationException"/>
      <doc>
      <![CDATA[This is overridden to ensure that this class's
 {@link #openFileWithOptions}() method is called, and so ultimately
 its {@link #open(Path, int)}.

 {@inheritDoc}]]>
      </doc>
    </method>
    <method name="openFileWithOptions" return="java.util.concurrent.CompletableFuture"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="parameters" type="org.apache.hadoop.fs.impl.OpenFileParameters"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Open the file as a blocking call to {@link #open(Path, int)}.

 {@inheritDoc}]]>
      </doc>
    </method>
    <method name="createFile" return="org.apache.hadoop.fs.FSDataOutputStreamBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[This is overridden to ensure that this class's create() method is
 ultimately called.

 {@inheritDoc}]]>
      </doc>
    </method>
    <method name="appendFile" return="org.apache.hadoop.fs.FSDataOutputStreamBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[This is overridden to ensure that this class's create() method is
 ultimately called.

 {@inheritDoc}]]>
      </doc>
    </method>
    <method name="hasPathCapability" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <param name="capability" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Disable those operations which the checksummed FS blocks.
 {@inheritDoc}]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Abstract Checksumed FileSystem.
 It provide a basic implementation of a Checksumed FileSystem,
 which creates a checksum file for each raw file.
 It generates &amp; verifies checksums at the client side.]]>
    </doc>
  </class>
  <!-- end class org.apache.hadoop.fs.ChecksumFileSystem -->
  <!-- start class org.apache.hadoop.fs.CommonConfigurationKeysPublic -->
  <class name="CommonConfigurationKeysPublic" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CommonConfigurationKeysPublic"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="NET_TOPOLOGY_SCRIPT_NUMBER_ARGS_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="NET_TOPOLOGY_SCRIPT_NUMBER_ARGS_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for NET_TOPOLOGY_SCRIPT_NUMBER_ARGS_KEY]]>
      </doc>
    </field>
    <field name="FS_DEFAULT_NAME_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_DEFAULT_NAME_DEFAULT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for FS_DEFAULT_NAME_KEY]]>
      </doc>
    </field>
    <field name="FS_DF_INTERVAL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_DF_INTERVAL_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for FS_DF_INTERVAL_KEY]]>
      </doc>
    </field>
    <field name="FS_DU_INTERVAL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_DU_INTERVAL_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for FS_DU_INTERVAL_KEY]]>
      </doc>
    </field>
    <field name="FS_GETSPACEUSED_CLASSNAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_GETSPACEUSED_JITTER_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_GETSPACEUSED_JITTER_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for FS_GETSPACEUSED_JITTER_KEY]]>
      </doc>
    </field>
    <field name="FS_CLIENT_RESOLVE_REMOTE_SYMLINKS_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_CLIENT_RESOLVE_REMOTE_SYMLINKS_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for FS_CLIENT_RESOLVE_REMOTE_SYMLINKS_KEY]]>
      </doc>
    </field>
    <field name="NET_TOPOLOGY_SCRIPT_FILE_NAME_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="NET_TOPOLOGY_NODE_SWITCH_MAPPING_IMPL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="NET_TOPOLOGY_IMPL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="NET_TOPOLOGY_TABLE_MAPPING_FILE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="NET_DEPENDENCY_SCRIPT_FILE_NAME_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FS_TRASH_CHECKPOINT_INTERVAL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_TRASH_CHECKPOINT_INTERVAL_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for FS_TRASH_CHECKPOINT_INTERVAL_KEY]]>
      </doc>
    </field>
    <field name="FS_PROTECTED_DIRECTORIES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Directories that cannot be removed unless empty, even by an
 administrator.]]>
      </doc>
    </field>
    <field name="FS_LOCAL_BLOCK_SIZE_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Not used anywhere, looks like default value for FS_LOCAL_BLOCK_SIZE]]>
      </doc>
    </field>
    <field name="FS_AUTOMATIC_CLOSE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_AUTOMATIC_CLOSE_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for FS_AUTOMATIC_CLOSE_KEY]]>
      </doc>
    </field>
    <field name="FS_CREATION_PARALLEL_COUNT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Number of filesystems instances can be created in parallel.
 <p></p>
 A higher number here does not necessarily improve performance, especially
 for object stores, where multiple threads may be attempting to create an FS
 instance for the same URI.
 <p></p>
 Default value: {@value}.]]>
      </doc>
    </field>
    <field name="FS_CREATION_PARALLEL_COUNT_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for {@link #FS_CREATION_PARALLEL_COUNT}.
 <p></p>
 Default value: {@value}.]]>
      </doc>
    </field>
    <field name="FS_FILE_IMPL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_FTP_HOST_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_FTP_HOST_PORT_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_TRASH_INTERVAL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_TRASH_INTERVAL_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for FS_TRASH_INTERVAL_KEY]]>
      </doc>
    </field>
    <field name="FS_CLIENT_TOPOLOGY_RESOLUTION_ENABLED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="FS_CLIENT_TOPOLOGY_RESOLUTION_ENABLED_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for FS_CLIENT_TOPOLOGY_RESOLUTION_ENABLED.]]>
      </doc>
    </field>
    <field name="IO_MAPFILE_BLOOM_SIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IO_MAPFILE_BLOOM_SIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IO_MAPFILE_BLOOM_SIZE_KEY]]>
      </doc>
    </field>
    <field name="IO_MAPFILE_BLOOM_ERROR_RATE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IO_MAPFILE_BLOOM_ERROR_RATE_DEFAULT" type="float"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IO_MAPFILE_BLOOM_ERROR_RATE_KEY]]>
      </doc>
    </field>
    <field name="IO_COMPRESSION_CODEC_LZO_CLASS_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Codec class that implements Lzo compression algorithm]]>
      </doc>
    </field>
    <field name="IO_MAP_INDEX_INTERVAL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IO_MAP_INDEX_INTERVAL_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IO_MAP_INDEX_INTERVAL_DEFAULT]]>
      </doc>
    </field>
    <field name="IO_MAP_INDEX_SKIP_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IO_MAP_INDEX_SKIP_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IO_MAP_INDEX_SKIP_KEY]]>
      </doc>
    </field>
    <field name="IO_SEQFILE_COMPRESS_BLOCKSIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IO_SEQFILE_COMPRESS_BLOCKSIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IO_SEQFILE_COMPRESS_BLOCKSIZE_KEY]]>
      </doc>
    </field>
    <field name="IO_FILE_BUFFER_SIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IO_FILE_BUFFER_SIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IO_FILE_BUFFER_SIZE_KEY]]>
      </doc>
    </field>
    <field name="IO_SKIP_CHECKSUM_ERRORS_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IO_SKIP_CHECKSUM_ERRORS_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IO_SKIP_CHECKSUM_ERRORS_KEY]]>
      </doc>
    </field>
    <field name="IO_SORT_MB_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="Moved to mapreduce, see mapreduce.task.io.sort.mb
 in mapred-default.xml
 See https://issues.apache.org/jira/browse/HADOOP-6801

 For {@link org.apache.hadoop.io.SequenceFile.Sorter} control
 instead, see {@link #SEQ_IO_SORT_MB_KEY}.">
      <doc>
      <![CDATA[@deprecated Moved to mapreduce, see mapreduce.task.io.sort.mb
 in mapred-default.xml
 See https://issues.apache.org/jira/browse/HADOOP-6801

 For {@link org.apache.hadoop.io.SequenceFile.Sorter} control
 instead, see {@link #SEQ_IO_SORT_MB_KEY}.]]>
      </doc>
    </field>
    <field name="IO_SORT_MB_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for {@link #IO_SORT_MB_KEY}.]]>
      </doc>
    </field>
    <field name="IO_SORT_FACTOR_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="Moved to mapreduce, see mapreduce.task.io.sort.factor
 in mapred-default.xml
 See https://issues.apache.org/jira/browse/HADOOP-6801

 For {@link org.apache.hadoop.io.SequenceFile.Sorter} control
 instead, see {@link #SEQ_IO_SORT_FACTOR_KEY}.">
      <doc>
      <![CDATA[@deprecated Moved to mapreduce, see mapreduce.task.io.sort.factor
 in mapred-default.xml
 See https://issues.apache.org/jira/browse/HADOOP-6801

 For {@link org.apache.hadoop.io.SequenceFile.Sorter} control
 instead, see {@link #SEQ_IO_SORT_FACTOR_KEY}.]]>
      </doc>
    </field>
    <field name="IO_SORT_FACTOR_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for {@link #IO_SORT_FACTOR_KEY}.]]>
      </doc>
    </field>
    <field name="SEQ_IO_SORT_MB_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="SEQ_IO_SORT_MB_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for {@link #SEQ_IO_SORT_MB_KEY}.]]>
      </doc>
    </field>
    <field name="SEQ_IO_SORT_FACTOR_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="SEQ_IO_SORT_FACTOR_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for {@link #SEQ_IO_SORT_FACTOR_KEY}.]]>
      </doc>
    </field>
    <field name="IO_SERIALIZATIONS_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="TFILE_IO_CHUNK_SIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="TFILE_IO_CHUNK_SIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for TFILE_IO_CHUNK_SIZE_DEFAULT]]>
      </doc>
    </field>
    <field name="TFILE_FS_INPUT_BUFFER_SIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="TFILE_FS_INPUT_BUFFER_SIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for TFILE_FS_INPUT_BUFFER_SIZE_KEY]]>
      </doc>
    </field>
    <field name="TFILE_FS_OUTPUT_BUFFER_SIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="TFILE_FS_OUTPUT_BUFFER_SIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for TFILE_FS_OUTPUT_BUFFER_SIZE_KEY]]>
      </doc>
    </field>
    <field name="HADOOP_CALLER_CONTEXT_ENABLED_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_CALLER_CONTEXT_ENABLED_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_CALLER_CONTEXT_MAX_SIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_CALLER_CONTEXT_MAX_SIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_CALLER_CONTEXT_SIGNATURE_MAX_SIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_CALLER_CONTEXT_SIGNATURE_MAX_SIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="IPC_CLIENT_CONNECTION_MAXIDLETIME_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECTION_MAXIDLETIME_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_CLIENT_CONNECTION_MAXIDLETIME_KEY]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECT_TIMEOUT_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECT_TIMEOUT_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_CLIENT_CONNECT_TIMEOUT_KEY]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECT_MAX_RETRIES_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECT_MAX_RETRIES_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_CLIENT_CONNECT_MAX_RETRIES_KEY]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECT_RETRY_INTERVAL_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECT_RETRY_INTERVAL_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_CLIENT_CONNECT_RETRY_INTERVAL_KEY]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECT_MAX_RETRIES_ON_SOCKET_TIMEOUTS_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_CONNECT_MAX_RETRIES_ON_SOCKET_TIMEOUTS_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_CLIENT_CONNECT_MAX_RETRIES_ON_SOCKET_TIMEOUTS_KEY]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_TCPNODELAY_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_TCPNODELAY_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_CLIENT_TCPNODELAY_KEY]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_LOW_LATENCY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Enable low-latency connections from the client]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_LOW_LATENCY_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value of IPC_CLIENT_LOW_LATENCY]]>
      </doc>
    </field>
    <field name="IPC_SERVER_LISTEN_QUEUE_SIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_SERVER_LISTEN_QUEUE_SIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_SERVER_LISTEN_QUEUE_SIZE_KEY]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_KILL_MAX_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_KILL_MAX_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_CLIENT_KILL_MAX_KEY]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_IDLETHRESHOLD_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_CLIENT_IDLETHRESHOLD_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_CLIENT_IDLETHRESHOLD_DEFAULT]]>
      </doc>
    </field>
    <field name="IPC_SERVER_TCPNODELAY_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_SERVER_TCPNODELAY_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_SERVER_TCPNODELAY_KEY]]>
      </doc>
    </field>
    <field name="IPC_SERVER_REUSEADDR_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_SERVER_REUSEADDR_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_SERVER_REUSEADDR_KEY.]]>
      </doc>
    </field>
    <field name="IPC_SERVER_MAX_CONNECTIONS_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="IPC_SERVER_MAX_CONNECTIONS_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for IPC_SERVER_MAX_CONNECTIONS_KEY]]>
      </doc>
    </field>
    <field name="IPC_SERVER_LOG_SLOW_RPC" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Logs if a RPC is really slow compared to rest of RPCs.]]>
      </doc>
    </field>
    <field name="IPC_SERVER_LOG_SLOW_RPC_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_RPC_SOCKET_FACTORY_CLASS_DEFAULT_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_RPC_SOCKET_FACTORY_CLASS_DEFAULT_DEFAULT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_SOCKS_SERVER_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_UTIL_HASH_TYPE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_UTIL_HASH_TYPE_DEFAULT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for HADOOP_UTIL_HASH_TYPE_KEY]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUP_MAPPING" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUPS_CACHE_SECS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUPS_CACHE_SECS_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUPS_NEGATIVE_CACHE_SECS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUPS_NEGATIVE_CACHE_SECS_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUPS_CACHE_WARN_AFTER_MS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUPS_CACHE_WARN_AFTER_MS_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_SECURITY_GROUPS_CACHE_BACKGROUND_RELOAD" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUPS_CACHE_BACKGROUND_RELOAD_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUPS_CACHE_BACKGROUND_RELOAD_THREADS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUPS_CACHE_BACKGROUND_RELOAD_THREADS_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUP_SHELL_COMMAND_TIMEOUT_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUP_SHELL_COMMAND_TIMEOUT_SECS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="use
 {@link CommonConfigurationKeysPublic#HADOOP_SECURITY_GROUP_SHELL_COMMAND_TIMEOUT_KEY}
 instead.">
      <doc>
      <![CDATA[@deprecated use
 {@link CommonConfigurationKeysPublic#HADOOP_SECURITY_GROUP_SHELL_COMMAND_TIMEOUT_KEY}
 instead.]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUP_SHELL_COMMAND_TIMEOUT_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_GROUP_SHELL_COMMAND_TIMEOUT_SECS_DEFAULT" type="long"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="use
 {@link CommonConfigurationKeysPublic#HADOOP_SECURITY_GROUP_SHELL_COMMAND_TIMEOUT_DEFAULT}
 instead.">
      <doc>
      <![CDATA[@deprecated use
 {@link CommonConfigurationKeysPublic#HADOOP_SECURITY_GROUP_SHELL_COMMAND_TIMEOUT_DEFAULT}
 instead.]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_AUTHENTICATION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_AUTHORIZATION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_INSTRUMENTATION_REQUIRES_ADMIN" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_SERVICE_USER_NAME_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_AUTH_TO_LOCAL" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_AUTH_TO_LOCAL_MECHANISM" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_DNS_INTERFACE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_DNS_NAMESERVER_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_TOKEN_FILES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_TOKENS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_HTTP_AUTHENTICATION_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_KERBEROS_MIN_SECONDS_BEFORE_RELOGIN" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_KERBEROS_MIN_SECONDS_BEFORE_RELOGIN_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for HADOOP_KERBEROS_MIN_SECONDS_BEFORE_RELOGIN]]>
      </doc>
    </field>
    <field name="HADOOP_KERBEROS_KEYTAB_LOGIN_AUTORENEWAL_ENABLED" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_KERBEROS_KEYTAB_LOGIN_AUTORENEWAL_ENABLED_DEFAULT" type="boolean"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Default value for HADOOP_KERBEROS_KEYTAB_LOGIN_AUTORENEWAL_ENABLED.]]>
      </doc>
    </field>
    <field name="HADOOP_RPC_PROTECTION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_SASL_PROPS_RESOLVER_CLASS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Class to override Sasl Properties for a connection]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_CRYPTO_CODEC_CLASSES_KEY_PREFIX" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_SECURITY_CRYPTO_CODEC_CLASSES_AES_CTR_NOPADDING_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_SECURITY_CRYPTO_CODEC_CLASSES_AES_CTR_NOPADDING_DEFAULT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_SECURITY_CRYPTO_CIPHER_SUITE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_CRYPTO_CIPHER_SUITE_DEFAULT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HADOOP_SECURITY_CRYPTO_JCE_PROVIDER_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_CRYPTO_JCEKS_KEY_SERIALFILTER" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_CRYPTO_BUFFER_SIZE_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_CRYPTO_BUFFER_SIZE_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Defalt value for HADOOP_SECURITY_CRYPTO_BUFFER_SIZE_KEY]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_IMPERSONATION_PROVIDER_CLASS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Class to override Impersonation provider]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_KEY_PROVIDER_PATH" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_KEY_DEFAULT_BITLENGTH_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_KEY_DEFAULT_BITLENGTH_DEFAULT" type="int"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Defalt value for HADOOP_SECURITY_KEY_DEFAULT_BITLENGTH_KEY.]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_KEY_DEFAULT_CIPHER_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@see
 <a href="{@docRoot}/../hadoop-project-dist/hadoop-common/core-default.xml">
 core-default.xml</a>]]>
      </doc>
    </field>
    <field name="HADOOP_SECURITY_KEY_DEFAULT_CIPHER_DEFAULT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Defalt value for HADOOP_SECURITY_KEY_DEFAULT_CIPHER_KEY.]]>
      </doc>
    </field>
    <field name="KMS_CLIENT_ENC_KEY_CACHE_SIZE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecate